(using Sys)
(using Sys.Type)
(using Sys.Reflection)

(namespace Sys.Sexml)

(interface Sys.Sexml.ISEXMLAttribute
	(Key -> (IString keyName))
	(ValueCount -> (Int32 valueCount))
	(Value (Int32 index) -> (IExpression s))
	(S -> (IExpression s))
	(Owner -> (Sys.Sexml.ISEXMLDirective directive))
)

// (directive (attribute1 ...)(attribute2 ...) : (child1 ...) (child2 ...))

(interface Sys.Sexml.ISEXMLDirective
	(Attribute (Int32 index) -> (Sys.Sexml.ISEXMLAttribute attr))
	(Count -> (Int32 nAttributes))
	(SubDirectives -> (Sys.Sexml.ISEXMLDirectiveList directives))
	(S -> (IExpression s))
)

(interface Sys.Sexml.ISEXMLDirectiveList
	(Count -> (Int32 numberOfDirectives))
	(Directive (Int32 index) -> (Sys.Sexml.ISEXMLDirective directive))
)

(interface Sys.Sexml.ISEXMLReader
	(RootDirective -> (Sys.Sexml.ISEXMLDirective directive))
	(S -> (IExpression s))
)

(class SEXMLReader 
	(implements Sys.Sexml.ISEXMLReader)
	
	(IExpression sexmlRoot)
	(Sys.Sexml.ISEXMLDirective rootDirective)
)

(function GetFirstChildThatMatchesArg (IExpression s)(IString arg)->(Int32 indexOfArg):
	(for (Int32 i = 0)(i < s.ChildCount)(i += 1)
		(IExpression child = (s i))
		(IString text = child.Text)
		(if ((Sys.Type.Strings.Compare text ":") != -1)
			(indexOfArg = i)
			(return)
		)
	)
	
	(indexOfArg = -1)
)

(method SEXMLReader.Construct (IExpression sexmlRoot):
	(this.sexmlRoot = sexmlRoot)	
	(Sys.Sexml.ISEXMLDirective rootDirective (Sys.Sexml.NewDirective sexmlRoot))
	(this.rootDirective = rootDirective)
)

(method SEXMLReader.RootDirective -> (Sys.Sexml.ISEXMLDirective directives):
	(directives = this.rootDirective)
)

(method SEXMLReader.Count -> (Int32 numberOfDirectives):
	(numberOfDirectives = this.nDirectives)
)

(method SEXMLReader.Directive (Int32 index) -> (Sys.Sexml.ISEXMLDirective directive):
	(directive = (this.topLevelDirectives index))
)

(method SEXMLReader.S -> (IExpression s):
	(s = this.s)
)

(factory Sys.Sexml.ReadSexml Sys.Sexml.ISEXMLReader (IExpression sexmlRoot):
	(construct SEXMLReader sexmlRoot)
)

(class SEXMLDirective
	(implements Sys.Sexml.ISEXMLDirectiveList)
	(implements Sys.Sexml.ISEXMLDirective)
	
	(IExpression sDir)
	
	(array Sys.Sexml.ISEXMLDirective subdirectives)
	(array Sys.Sexml.ISEXMLAttribute attributes)
		
	(Int32 nSubdirectives)
	(Int32 nAttributes)
)

(method SEXMLDirective.Count -> (Int32 numberOfDirectives):
	(numberOfDirectives = this.nDirectives)
)

(method SEXMLDirective.Directive (Int32 index) -> (Sys.Sexml.ISEXMLDirective directive):
	(directive = (this.subdirectives index))
)

(method SEXMLDirective.Attribute (Int32 index) -> (Sys.Sexml.ISEXMLAttribute attr):
	(attr = (this.attributes index))
)

(method SEXMLDirective.SubDirectives -> (Sys.Sexml.ISEXMLDirectiveList directives):
	(directives = this)
)

(method SEXMLDirective.S -> (IExpression s):
	(s = this.sDir)
)

(function BuildMatchStatement (IExpression in)(IExpressionBuilder out)-> :
	(if (in.ChildCount < 3)
		(in.Throw 0 "Expecting at least 3 children: (#Sys.match <text-variable> (key1 (command1 ...))(key2 (command2 ...)))")
	)
	
	(IExpression variableName = (in 1))
	
	(Int32 type = variableName.Type)
	(if (type != (#Sys.Reflection.ExpressionTypeAtomic))
		(variableName.Throw 0 "Expecting atomic value for <text-variable>")
	)
	
	(for (Int32 i = 2)(i < in.ChildCount)(i += 1)
		(IExpression matchLineCommand = (in i))
		
		(if (matchLineCommand.ChildCount < 2)
			(matchLineCommand.Throw 0 "Expecting more than one expression on the match line")
		)
		
		(IExpression key = (matchLineCommand 0))
		
		(IExpressionBuilder owner = out)
		
		(Int32 matchType = key.Type)
		
		(if ((matchType == (#Sys.Reflection.ExpressionTypeString)) or (matchType == (#Sys.Reflection.ExpressionTypeAtomic)))
			(Sys.Type.IString keyName = key.Text)
			(IExpressionBuilder matchImpl = owner.AddCompound)
			(matchImpl.AddAtomic "if")
				(IExpressionBuilder booleanImpl = matchImpl.AddCompound)
					// (if ((Sys.Type.Strings.Compare key target)== 0) ... else...)
					(IExpressionBuilder compareInvocationImpl = booleanImpl.AddCompound)
						(compareInvocationImpl.AddAtomic "Sys.Type.Strings.Compare")
						(compareInvocationImpl.AddAtomic variableName.Text)
						(compareInvocationImpl.AddStringLiteral keyName)
					(booleanImpl.AddAtomic "==")
					(booleanImpl.AddAtomic "0")
					
				(for (Int32 j = 1)(j < matchLineCommand.ChildCount)(j += 1)
					(matchImpl.Copy (matchLineCommand j))
				)
				
				(matchImpl.AddAtomic "else")
				(owner = matchImpl)			
		else
			(key.Throw 0 "Key: Expecting atomic or string literal")
		)
	)
)

/*  Executes the command expressions with the matching key. Atomic or string literals are both legitimate values
	usage: 
	(#Sys.StringMatch text-variable
		(key1 (commands...))
		...
		(keyN (commands...))
	)
	
	Example:
	(IString answer = "Yes")
	(#Sys.StringMatch answer
		(Yes (#print "You typed yes"))
		("No"  (#print "You typed no"))
	) 
	
	the above emits "You typed yes"
*/
(macro Sys.StringMatch in out
	(Sys.ValidateSubscriptRange in.ChildCount 3 1000000 "Usage: (#Sys.StringMatch text-variable (key1 (command...)(key2 (command ...))))")
	(BuildMatchStatement in out)
)

(method SEXMLDirective.Construct (IExpression s) :
	(this.sDir = s)
	
	(Int32 indexOfColon = (GetFirstChildThatMatchesArg s ":"))
	(if (indexOfColon >= 1)
		(this.nAttributes = indexOfColon - 1)
		(this.nSubdirectives = (s.ChildCount - indexOfColon) - 1)
	else
		(this.nAttributes = 0)
		(this.nSubdirectives = s.ChildCount)
	)
	
	(for (Int32 i = indexOfColon + 1)(i < s.ChildCount)(i += 1)
		(Sys.Sexml.ISEXMLDirective directive (Sys.Sexml.NewDirective (s i)))
		(this.subdirectives.Push directive)
	)
	
	(for (i = 1)(i < indexOfColon)(i += 1)
		(IExpression sAttribute = (s i))
		(Int32 attrType = sAttribute.Type)
		(if (attrType != (#Sys.Reflection.ExpressionTypeCompound))
			(sAttribute.Throw 0 "Expecting compound definition of an attribute (Key <...value(s)...>)")
		)
		
		(if (sAttribute.ChildCount < 1)
			(sAttribute.Throw 0 "Expecting (<keyname> ...) but attribute had no children")
		)
	
		(IExpression sKey = (sAttribute 0))
		(Int32 keyType = sKey.Type)
		(if (keyType != (#Sys.Reflection.ExpressionTypeAtomic))
			(sKey.Throw 0 "Expecting expression to be a string key or type indicator")
		)
		
		(Int32 nExpectedValues = 1)
		
		(Sys.Type.IString t0 = sKey.Text)

		(#Sys.StringMatch t0
			("#Vec2i" (nExpectedValues = 2))
			("#Vec3i" (nExpectedValues = 3))
			("#Vec4i" (nExpectedValues = 4))
			("#Recti" (nExpectedValues = 4))
			("#Quat" (nExpectedValues = 4))
			("#Vec2" (nExpectedValues = 2))
			("#Vec3" (nExpectedValues = 3))
			("#Vec4" (nExpectedValues = 4))
			("#Rect" (nExpectedValues = 4))
			("#List" (nExpectedValues = sAttribute.ChildCount - 2))
		)
		
		(if (nExpectedValues == 1)
			(if (sAttribute.ChildCount != 2)
				(sAttribute.Throw 0 "Expecting two elements: (<key> <value>)")
			)
			
			(Sys.Sexml.ISEXMLAttribute a (Sys.Sexml.NewAttribute sKey.Text sAttribute this))
			(this.attributes.Push a)
		else
			(Int32 childCount = sAttribute.ChildCount)
			(if (childCount != (nExpectedValues + 2))
				(
					(#Sys.Type.paragraph msg "Expecting (" t0 " <key> <..." nExpectedValues " values...>)")
					(sAttribute.Throw 0 msg)
				)
			)
			
			(IExpression sKeyName = (sAttribute 1))
			(Int32 keyNameType = sKeyName.Type)
			(if (keyNameType != (#Sys.Reflection.ExpressionTypeAtomic))
				(sKeyName.Throw 0 "Expecting atomic value for keyname")
			)
			
			(Sys.Sexml.ISEXMLAttribute a (Sys.Sexml.NewAttribute sKeyName.Text sAttribute this))
			(this.attributes.Push a)
		)
	)
)

(factory Sys.Sexml.NewDirective Sys.Sexml.ISEXMLDirective (IExpression sexmlDirectiveExpression):
	(construct SEXMLDirective sexmlDirectiveExpression)
)

(class SEXMLAttribute
	(implements Sys.Sexml.ISEXMLAttribute)
	(Sys.Reflection.IExpression s)
	(Sys.Sexml.ISEXMLDirective directive)
	(Sys.Type.IString key)
	(Int32 valueCount)
)

(method SEXMLAttribute.Construct (Sys.Type.IString key)(IExpression s)(Sys.Sexml.ISEXMLDirective parentDirective):
	(this.s = s)
	(this.directive = parentDirective)
	(this.key = key)
	(this.valueCount = (s.ChildCount == 2) ?? 1 (s.ChildCount - 2))
)

(method SEXMLAttribute.Key -> (IString keyName):
	(keyName = this.key)
)

(method SEXMLAttribute.ValueCount -> (Int32 nValues):
	(nValues = this.valueCount)
)

(method SEXMLAttribute.Value (Int32 index) -> (IExpression sValue):
	(if (s.ChildCount == 2)
		(sValue = s.Child (index + 1))
	else
		(sValue = s.Child (index + 2))
	)
)

(method SEXMLAttribute.S -> (IExpression sExpr):
	(sExpr = this.s)
)

(method SEXMLAttribute.Owner -> (Sys.Sexml.ISEXMLDirective owner):
	(owner = this.directive)
)


(factory Sys.Sexml.NewAttribute Sys.Sexml.ISEXMLAttribute (Sys.Type.IString key)(IExpression s)(Sys.Sexml.ISEXMLDirective parentDirective):
	(construct SEXMLAttribute key s parentDirective)
)
