#pragma once

#include <rococo.types.h>
#include <sexy.types.h>
#include <stdio.h>
#include <sexy.s-parser.h>
#include "sexy.strings.h"
#include <sexy.stdstrings.h>
#include <unordered_map>

namespace Rococo
{
   using namespace Sex;

   bool AreEqual(csexstr s, const sexstring& t);

   class FileAppender
   {
   private:
      FILE* hFile;
      csexstr filename;
   public:
      FileAppender(csexstr _filename);
      ~FileAppender();

      void Append(csexstr format, ...);
      void Append(char c);
      void AppendSequence(int count, char c);
   };

   void WriteStandardErrorCode(int errorCode);
   int64 GetLastModifiedDate(const char* path);

   void GetFQCppStructName(SEXCHAR* compressedStructName, SEXCHAR* cppStructName, size_t capacity, csexstr fqStructName);

   struct TypeDef
   {
      Rococo::stdstring sexyType;
      Rococo::stdstring cppType;
   };

   typedef std::unordered_map<Rococo::stdstring, TypeDef> TTypeMap;

   class CppType
   {
   private:
      enum { MAX_TOKEN_LEN = 256 };
      SEXCHAR bennyHillDef[MAX_TOKEN_LEN];
      SEXCHAR compressedName[MAX_TOKEN_LEN];
      SEXCHAR fqName[MAX_TOKEN_LEN];

   public:
      CppType()
      {
         bennyHillDef[0] = 0;
         compressedName[0] = 0;
         fqName[0] = 0;
      }

      void Set(csexstr bennyHillDef)
      {
         CopyString(this->bennyHillDef, MAX_TOKEN_LEN, bennyHillDef);
         GetFQCppStructName(compressedName, fqName, 256, bennyHillDef);
      }

      csexstr CompressedName() const
      {
         return compressedName;
      }

      csexstr FQName() const
      {
         return fqName;
      }

      csexstr SexyName() const
      {
         return bennyHillDef;
      }
   };

   typedef std::vector<const Rococo::Sex::ISExpression*> TExpressions;

   struct InterfaceContext
   {
      enum { MAX_TOKEN_LEN = 256 };
      CppType asCppInterface;
      SEXCHAR asSexyInterface[MAX_TOKEN_LEN];
      SEXCHAR appendSexyFile[_MAX_PATH];
      SEXCHAR appendCppHeaderFile[_MAX_PATH];
      SEXCHAR appendCppImplFile[_MAX_PATH];

      SEXCHAR inheritanceString[128];

      bool isSingleton; // If true then the context comes from the native registration method, else it comes from the factory.
      CppType nceContext;
      bool hasDestructor;
      TExpressions factories;

      InterfaceContext()
      {
         asSexyInterface[0] = 0;
         appendSexyFile[0] = 0;
         appendCppHeaderFile[0] = 0;
         appendCppImplFile[0] = 0;
         hasDestructor = false;
         isSingleton = false;
      }
   };

   struct InterfaceDef
   {
      InterfaceContext ic;
      const Rococo::Sex::ISExpression* sdef;
      const Rococo::Sex::ISExpression* methods;
   };

   struct EnumContext
   {
      enum { MAX_TOKEN_LEN = 256 };
      CppType underlyingType;
      CppType asCppEnum;
      SEXCHAR asSexyEnum[MAX_TOKEN_LEN];
      SEXCHAR appendSexyFile[_MAX_PATH];
      SEXCHAR appendCppHeaderFile[_MAX_PATH];
      SEXCHAR appendCppImplFile[_MAX_PATH];
      std::vector<std::pair<stdstring, int64>> values;

      EnumContext()
      {
         asSexyEnum[0] = 0;
         appendSexyFile[0] = 0;
         appendCppHeaderFile[0] = 0;
         appendCppImplFile[0] = 0;
      }
   };

   struct EnumDef
   {
      EnumContext ec;
      const Rococo::Sex::ISExpression* sdef;
   };

   struct ParseContext
   {
      Rococo::SEXCHAR scriptInput[_MAX_PATH];              // Full path of the sxh file
      Rococo::SEXCHAR projectRoot[_MAX_PATH];              // Where the config and sxh files are found
      Rococo::SEXCHAR scriptName[_MAX_PATH];               // Extracted from the sxh filename, gives a short name for the script
      Rococo::SEXCHAR scriptInputSansExtension[_MAX_PATH]; // Containing directory of the sxh file
      Rococo::SEXCHAR cppRootDirectory[_MAX_PATH];         // Root where C++ are to be generated
      Rococo::SEXCHAR cppTypesFilename[_MAX_PATH];         // C++ types file generated by the sxh file
      Rococo::SEXCHAR sexyTypesFilename[_MAX_PATH];        // Sexy types file generated by the sxh file
      Rococo::SEXCHAR cppException[128];                   // cpp exception tyoe caught in native code

      TTypeMap primitives;
      TTypeMap structs;
      std::unordered_map<Rococo::stdstring, InterfaceDef*> interfaces;
      std::vector<EnumDef> enums;
   };

   Rococo::csexstr StringFrom(Rococo::Sex::cr_sex s);
   Rococo::csexstr StringFrom(Rococo::Sex::cr_sex command, int elementIndex);

   void AppendCppType(FileAppender& appender, cr_sex field, csexstr fieldtype, const ParseContext& pc);
}
