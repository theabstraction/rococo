(' #file.type rococo.hv)

(namespace EntryPoint)
	(alias Main EntryPoint.Main)

(using Sys.Maths)
(using Sys.Maths.I32)
(using Sys.Maths.F32)
(using HV)
(using Sys.Type)
(using Sys.Geometry.F32)
(using Sys.Random)
(using Rococo)
(using Rococo.Graphics)
(using Rococo.Entities)

(function DoesWallOpposeGap (GapSegment gap)(WallSegment wall)->(Bool isOpposed):
	(Float32 dotProduct = (Sys.Geometry.F32.Dot gap.normal wall.normal))
	(if (dotProduct == -1)
		(IMessaging messaging (Messaging))
		(messaging.Log "The script found an opposing wall to the gap")
		(isOpposed = true)
	else
		(isOpposed = false)
	)
)

(function GetOpposingWall (ISectorFloorTesselator sector)(WallSegment wall)(GapSegment gap)-> :
	(Int32 nWalls = sector.NumberOfSegments )
	(#for (Int32 i = 0)(i < nWalls)(i += 1)
		(sector.GetSegment i wall)
		(if (DoesWallOpposeGap gap wall)
			(break)
		)
	)
)

(function GetQuadFromGapAndWall (Float32 z0)(Float32 z1)(QuadVertices floor)(QuadVertices ceiling)(WallSegment wall)(GapSegment gap)-> :
	/*
	(struct QuadVertices
		(Sys.Maths.Quadf positions)
		(Sys.Maths.Rectf uv)
		(Sys.Maths.Quadf normals)
		(Rococo.QuadColours colours)
	)
	*/
	
	(floor.normals.a = 0 0 1)
	(floor.normals.b = 0 0 1)
	(floor.normals.c = 0 0 1)
	(floor.normals.d = 0 0 1)
	(floor.colours.a = 0xFFFFFFFF)
	(floor.colours.b = 0xFFFFFFFF)
	(floor.colours.c = 0xFFFFFFFF)
	(floor.colours.d = 0xFFFFFFFF)
	(floor.uv.left = 0)
	(floor.uv.top  = 0)
	(floor.uv.right = 1)
	(floor.uv.bottom = 1)
	
	(floor.positions.a = gap.quad.d)
	(floor.positions.b = gap.quad.c)
	(floor.positions.c = wall.quad.d)
	(floor.positions.d = wall.quad.c)
	
	(floor.positions.a.z = z0)
	(floor.positions.b.z = z0)
	(floor.positions.c.z = z0)
	(floor.positions.d.z = z0)
	
	(ceiling.positions.a = gap.quad.b)
	(ceiling.positions.b = gap.quad.a)
	(ceiling.positions.c = wall.quad.b)
	(ceiling.positions.d = wall.quad.a)
	(ceiling.positions.a.z = z1)
	(ceiling.positions.b.z = z1)
	(ceiling.positions.c.z = z1)
	(ceiling.positions.d.z = z1)
	
	(ceiling.normals.a = 0 0 -1)
	(ceiling.normals.b = 0 0 -1)
	(ceiling.normals.c = 0 0 -1)
	(ceiling.normals.d = 0 0 -1)
	(ceiling.colours.a = 0xFF000000)
	(ceiling.colours.b = 0xFF000000)
	(ceiling.colours.c = 0)
	(ceiling.colours.d = 0)
	(Vec3 ceilingDirection = ceiling.positions.c - ceiling.positions.a)
	(Float32 len = (Sys.Geometry.F32.Length ceilingDirection))
	
	(Vec3 ceilingTangent = ceiling.positions.b - ceiling.positions.a)
	(Float32 tanLen = (Sys.Geometry.F32.Length ceilingTangent))
	(ceiling.uv.left = 0)
	(ceiling.uv.top  = 0)
	(ceiling.uv.right = (0.25 * tanLen))
	(ceiling.uv.bottom = (0.25 * len))
)

(function AddQuadToFloor (QuadVertices q)(IQuadStackTesselator qst)(ISectorFloorTesselator sector)(MaterialVertexData mat)-> :
	(qst.PushQuad q mat)
	(qst.MoveInputToOutput)
		
	(VertexTriangle topLeft)
	(VertexTriangle bottomRight)
	(while (qst.PopOutputAsTriangles topLeft bottomRight)
		(sector.AddFloorTriangle topLeft)
		(sector.AddFloorTriangle bottomRight)
	)
	
	(qst.Clear)
)

(function AddQuadToCeiling (QuadVertices q)(IQuadStackTesselator qst)(ISectorFloorTesselator sector)(MaterialVertexData mat)-> :
	(qst.PushQuad q mat)
	(qst.MoveInputToOutput)
		
	(VertexTriangle topLeft)
	(VertexTriangle bottomRight)
	(while (qst.PopOutputAsTriangles topLeft bottomRight)
		(sector.AddCeilingTriangle topLeft)
		(sector.AddCeilingTriangle bottomRight)
	)
	
	(qst.Clear)
)

(function SetQuadNormals (QuadVertices q)(Float32 dx)(Float32 dy)(Float32 dz)-> :
	(q.normals.a = dx dy dz)
	(q.normals.b = dx dy dz)
	(q.normals.c = dx dy dz)
	(q.normals.d = dx dy dz)
)

(function GenerateGraphicsMesh (Int32 sectorId) (ISectorFloorTesselator sector) -> :
	(MaterialVertexData steps)
	(sector.GetMaterial steps "casing")
	
	(MaterialVertexData physics)
	(sector.GetMaterial physics "physics.hull")
	
	(IQuadStackTesselator qst (QuadStackTesselator))
	
	(IScriptConfig config (ScriptConfig))
	(Float32 uvScale = (config.GetFloat "UV size" 0.5 0.01 10))
	(Float32 stepWidth = (config.GetFloat "Step width (m)" 1.0 0.1 10))
	(Float32 stepHeight = (config.GetFloat "Step height(m)" 0.15 0.1 100))
	
	(GapSegment gap)
	(sector.GetGap 0 gap)
	
	(WallSegment wall)
	(GetOpposingWall sector wall gap)
	
	(ISectorEnumerator sectors (SectorEnumerator))
	(ISectorLayout layout = (sectors.GetSectorById sectorId))
	(Vec2 alts)
	(layout.Altitude alts)
	(Float32 z0 = alts.x)
	(Float32 z1 = alts.y)
	
	(QuadVertices floor)
	(QuadVertices ceiling)
	(GetQuadFromGapAndWall z0 z1 floor ceiling wall gap)
	
	(AddQuadToCeiling ceiling qst sector steps)	
	
	(QuadVertices stepHorz)
	(stepHorz = floor)
	
	(Vec3 dV = floor.positions.a - floor.positions.d)
	(Float32 len = (Sys.Geometry.F32.Length dV))
	(Float32 totalLen = len)
	
	(Vec3 dS = gap.normal * stepWidth)
	
	(Vec3 a = floor.positions.a)
	(Vec3 b = floor.positions.b)
	
	(QuadVertices stepH = floor)
	(SetQuadNormals stepH 0 0 1)
	
	(QuadVertices stepV = floor)
	(SetQuadNormals stepV wall.normal.x wall.normal.y wall.normal.z)
	
	(QuadVertices backWall)
	(backWall.positions = wall.quad)
	(SetQuadNormals backWall wall.normal.x wall.normal.y wall.normal.z)
	(backWall.colours.a = 0)
	(backWall.colours.b = 0)
	(backWall.colours.c = 0)
	(backWall.colours.d = 0)
	(AddQuadToFloor backWall qst sector steps)	
	
	(Vec3 stepTangent = gap.quad.a - gap.quad.b)
	(Float32 stepTangentLength = (Sys.Geometry.F32.Length stepTangent))
	
	(Float32 u = 0)
	
	(#for (Float32 s = 0)(s < totalLen)(s += stepWidth)
		(Float32 blendA = (1 - (s / totalLen)))
		(Float32 blendB = (1 - ((s + stepWidth) / totalLen)))
		
		(stepV.positions.a = a)
		(stepV.positions.b = b)
		
		(Float32 deltaV = (AnyFloat 0 1))
		(Float32 delta2V = (deltaV + stepTangentLength))
		(Float32 gammaV = (AnyFloat 0 1))
		(Float32 gamma2V = (deltaV + stepHeight))
		
		(Float32 colBlend = (AnyFloat 0.9 1))
		(Float32 blendAR = (colBlend * blendA))
		(Float32 blendBR = (colBlend * blendB))
		
		(Float32 colR = ((AnyFloat 0.9 1) * blendAR))
		(Float32 colG = ((AnyFloat 0.9 1) * blendAR))
		(Float32 colB = ((AnyFloat 0.9 1) * blendAR))
		
		(stepV.uv = deltaV gammaV delta2V gamma2V)
		(stepV.colours.a = (Sys.Type.ToRGBA colR colG colB blendAR))
		(stepV.colours.b = stepV.colours.a)
		(stepV.colours.c = stepV.colours.a)
		(stepV.colours.d = stepV.colours.a)
		(stepH.colours.a = (Sys.Type.ToRGBA colR colG colB blendAR))
		(stepH.colours.b = stepH.colours.a)
		(stepH.colours.c = (Sys.Type.ToRGBA colR colG colB blendBR))
		(stepH.colours.d = (Sys.Type.ToRGBA colR colG colB blendBR))
		(stepH.positions.a = a)
		(stepH.positions.a.z = (stepH.positions.a.z + stepHeight))
		(stepH.positions.b = b)
		(stepH.positions.b.z = (stepH.positions.b.z + stepHeight))
		
		(Float32 delta = (AnyFloat 0 1))
		(Float32 delta2 = (delta + stepTangentLength))
		(Float32 gamma = (AnyFloat 0 1))
		(Float32 gamma2 = (gamma + stepWidth))
		(stepH.uv = delta gamma delta2 gamma2)
		
		(stepV.positions.c = stepH.positions.b)
		(stepV.positions.d = stepH.positions.a)

		(stepH.positions.d = stepH.positions.a + dS)
		(stepH.positions.c = stepH.positions.b + dS)
		(b = stepH.positions.c)
		(a = stepH.positions.d)
		
		(Vec3 skirtHeight = 0 0 0.1)
		
		(QuadVertices rightWallStrip = stepH)
		(rightWallStrip.positions.a = stepH.positions.a)
		(rightWallStrip.positions.b = stepH.positions.d)
		(rightWallStrip.positions.c = rightWallStrip.positions.b + skirtHeight)
		(rightWallStrip.positions.d = rightWallStrip.positions.a + skirtHeight)
		(rightWallStrip.colours.a = (Sys.Type.ToRGBA 0 0 0 0))
		(rightWallStrip.colours.b = (Sys.Type.ToRGBA 0 0 0 0))
		(rightWallStrip.colours.c = (Sys.Type.ToRGBA 0 0 0 blendA))
		(rightWallStrip.colours.d = (Sys.Type.ToRGBA 0 0 0 blendB))
		
		(Float32 u = (uvScale * s))
		(Float32 v = (uvScale * stepH.positions.a.z))
		(Float32 v1 = (v + (uvScale * skirtHeight.z)))
		(Float32 u1 = (u + (uvScale * stepWidth)))
		(rightWallStrip.uv = u v u1 v1)
		(SetQuadNormals rightWallStrip gap.tangent.x gap.tangent.y gap.tangent.z)
		
		(Float32 dH = (z1 - z0))
		(Vec3 skirtToCeiling = 0 0 dH)
		
		(Float32 v2 = (uvScale * (v1 + skirtToCeiling.z)))
		
		(QuadVertices upperRightWallStrip = rightWallStrip)
		(upperRightWallStrip.positions.a = rightWallStrip.positions.d)
		(upperRightWallStrip.positions.b = rightWallStrip.positions.c)
		(upperRightWallStrip.positions.c = upperRightWallStrip.positions.b + skirtToCeiling)
		(upperRightWallStrip.positions.d = upperRightWallStrip.positions.a + skirtToCeiling)	
		(upperRightWallStrip.colours.a = (Sys.Type.ToRGBA 0 0 0 blendA))
		(upperRightWallStrip.colours.b = (Sys.Type.ToRGBA 0 0 0 blendB))
		(upperRightWallStrip.colours.c = (Sys.Type.ToRGBA 0 0 0 blendB))
		(upperRightWallStrip.colours.d = (Sys.Type.ToRGBA 0 0 0 blendA))
		(upperRightWallStrip.uv = u v1 u1 v2)
		
		(AddQuadToFloor upperRightWallStrip qst sector steps)	
		(AddQuadToFloor rightWallStrip qst sector steps)

		(QuadVertices leftWallStrip = stepH)
		(leftWallStrip.positions.a = stepH.positions.c)
		(leftWallStrip.positions.b = stepH.positions.b)
		(leftWallStrip.positions.c = leftWallStrip.positions.b + skirtHeight)
		(leftWallStrip.positions.d = leftWallStrip.positions.a + skirtHeight)
		(leftWallStrip.uv = u1 v u v1)
		(leftWallStrip.colours.a = (Sys.Type.ToRGBA 0 0 0 0))
		(leftWallStrip.colours.b = (Sys.Type.ToRGBA 0 0 0 0))
		(leftWallStrip.colours.c = (Sys.Type.ToRGBA 0 0 0 blendA))
		(leftWallStrip.colours.d = (Sys.Type.ToRGBA 0 0 0 blendB))
		
		(Vec3 tangent = gap.tangent * -1.0)
		(SetQuadNormals leftWallStrip tangent.x tangent.y tangent.z)	
		(AddQuadToFloor leftWallStrip qst sector steps)	

		(QuadVertices upperLeftWallStrip = leftWallStrip)
		(upperLeftWallStrip.colours.a = (Sys.Type.ToRGBA 0 0 0 blendB))
		(upperLeftWallStrip.colours.b = (Sys.Type.ToRGBA 0 0 0 blendA))
		(upperLeftWallStrip.colours.c = (Sys.Type.ToRGBA 0 0 0 blendA))
		(upperLeftWallStrip.colours.d = (Sys.Type.ToRGBA 0 0 0 blendB))
		(upperLeftWallStrip.positions.a = leftWallStrip.positions.d)
		(upperLeftWallStrip.positions.b = leftWallStrip.positions.c)
		(upperLeftWallStrip.positions.c = upperLeftWallStrip.positions.b + skirtToCeiling)
		(upperLeftWallStrip.positions.d = upperLeftWallStrip.positions.a + skirtToCeiling)	
		(upperLeftWallStrip.uv = u v1 u1 v2)
		(AddQuadToFloor upperLeftWallStrip qst sector steps)		
		
		(AddQuadToFloor stepH qst sector steps)		
		(AddQuadToFloor stepV qst sector steps)		
		(AddQuadToFloor stepH qst sector physics)		
	)
)

(function Main (Int32 sectorId)->(Int32 exitCode):
	(IInstances instances (Instances))
	
	(ISectorFloorTesselator sector (SectorFloorTesselator))
	(IQuadStackTesselator qst (QuadStackTesselator))
	
	(qst.Clear)
	
	(if (sector.NumberOfGaps == 0)
		(IMessaging messaging (Messaging))
		(messaging.Log "There are no gaps in the sector")
		(return)
	)
	
	(if (sector.FoundationsExist == false)
		// Axis aligned rectangular room
	
		(if (sector.NumberOfGaps != 1)
			(IMessaging messaging (Messaging))
			(messaging.Log "The stairs script requires a sector to be rectangular and have one connected sector")
			(return)
		)
	
		(qst.Clear)
		
		(GenerateGraphicsMesh sectorId sector)
	else
		(IMessaging messaging (Messaging))
		(messaging.Log "The script requires a sector to be rectangular")
	)
)