#include "sexystudio.api.h"
#include <sexy.types.h>
#include <Sexy.S-Parser.h>
#include <rococo.strings.h>

#include <string>
#include <vector>
#include <rococo.hashtable.h>
#include <memory>
#include <algorithm>

#include <rococo.auto-release.h>

#include <rococo.io.h>

using namespace Rococo;
using namespace Rococo::Sex;
using namespace Rococo::SexyStudio;

fstring pckPrefix = "[package]:"_fstring;

cstr AlwaysGetAtomic(cr_sex s)
{
	return IsAtomic(s) ? s.String()->Buffer : "<expected atomic argument>";
}

cstr AlwaysGetAtomic(cr_sex s, int index)
{
	if (index < 0 || index >= s.NumberOfElements()) return "<invalid subexpression index>";
	return IsAtomic(s[index]) ? s[index].String()->Buffer : "<expected atomic argument>";
}

namespace Rococo::SexyStudio
{
	ParseKeyword keywordNamespace("namespace");
	ParseKeyword keywordInterface("interface");
	ParseKeyword keywordStruct("struct");
	ParseKeyword keywordFunction("function");
	ParseKeyword keywordMacro("macro");
	ParseKeyword keywordAlias("alias");
	ParseKeyword keywordFactory("factory");
	ParseKeyword keywordArchetype("archetype");
	ParseKeyword keywordClass("class");
	AtomicArg ParseAtomic;

	cstr FindDot(cstr s)
	{
		while (*s != '.' && *s != 0)
		{
			s++;
		}

		return s;
	}

	cr_sex GetElement(cr_sex s, int index)
	{
		return s[index];
	}

	int Len(cr_sex s)
	{
		return s.NumberOfElements();
	}

	bool AtomicArg::Matches(cr_sex sParent, int index) const
	{
		cr_sex s = sParent[index];
		return IsAtomic(s);
	}

	fstring AtomicArg::operator()(cr_sex sParent, int index) const
	{
		cr_sex s = sParent[index];
		return fstring{ s.String()->Buffer, s.String()->Length };
	}

	ParseKeyword::ParseKeyword(cstr _keyword) : keyword(to_fstring(_keyword))
	{
	}

	bool ParseKeyword::Matches(cr_sex sParent, int index) const
	{
		cr_sex s = sParent[index];
		if (!IsAtomic(s)) return false;
		return Eq(s.String()->Buffer, keyword);
	}

	fstring ParseKeyword::operator()(cr_sex s, int index) const
	{
		return keyword;
	}
}

namespace ANON
{
	struct SXYAttribute
	{
		const ISExpression* sAttribute;
		cstr GetName() const
		{
			return AlwaysGetAtomic(*sAttribute, 1);
		}
	};

	struct SXYMethod: ISXYFunction
	{
		const ISExpression* psMethod;
		cstr name = nullptr;
		int mapIndex = 0;
		int classOffset;
		int finalArg;

		int InputCount() const override
		{
			return mapIndex <= 0 ? 0 : mapIndex - 1 - classOffset;
		}

		int OutputCount() const override
		{
			return mapIndex <= 0 ? 0 : finalArg - mapIndex;
		}

		cstr SourcePath() const override
		{
			return "<no path>";
		}

		cstr InputType(int index) const override
		{
			cr_sex sArg = psMethod->GetElement(index + 1 + classOffset);
			return AlwaysGetAtomic(sArg, 0);
		}

		cstr OutputType(int index) const override
		{
			cr_sex sArg = psMethod->GetElement(index + mapIndex + 1);
			return AlwaysGetAtomic(sArg, 0);
		}

		cstr InputName(int index) const override
		{
			cr_sex sArg = psMethod->GetElement(index + 1 + classOffset);
			return AlwaysGetAtomic(sArg, 1);
		}

		cstr OutputName(int index) const override
		{
			cr_sex sArg = psMethod->GetElement(index + mapIndex + 1);
			return AlwaysGetAtomic(sArg, 1);
		}

		cstr PublicName() const
		{
			return name;
		}
		
		SXYMethod(cr_sex _sMethod, bool isClassMethod = false) : psMethod(&_sMethod), classOffset(isClassMethod ? 1 : 0),
			finalArg(0)
		{
			// Assumes s_Method.NumberOfElements >= 2 and s_Method[0] is atomic
			// Example: (AppendPrefixAndGetName (IString prefix)->(IString name))

			name = AlwaysGetAtomic(_sMethod, classOffset);

			if (isClassMethod)
			{
				name = FindDot(name) + 1;
			}

			for (int i = 1 + classOffset; i < _sMethod.NumberOfElements(); ++i)
			{
				if (IsAtomic(_sMethod[i]))
				{
					cstr arg = _sMethod[i].String()->Buffer;
					if (Eq(arg, "->"))
					{
						mapIndex = i;
						break;
					}
				}
			}

			finalArg = _sMethod.NumberOfElements() - 1;

			if (mapIndex)
			{
				if (isClassMethod)
				{
					for (int i = mapIndex + 1; i < _sMethod.NumberOfElements(); ++i)
					{
						if (IsAtomic(_sMethod[i]))
						{
							cstr arg = _sMethod[i].String()->Buffer;
							if (Eq(arg, ":"))
							{
								finalArg = i - 1;
								break;
							}
						}
					}
				}
				else
				{
					finalArg = _sMethod.NumberOfElements() - 1;
				}
			}
		}
	};

	void ResolvePackageName(cstr fqName, char* buf, size_t capacity, cr_sex s)
	{
		// fqName in this context has form $.<name>, where $ indicated the default namespace generated by the resource path.

		cstr packagePath = s.Tree().Source().Name();
		if (Compare(packagePath, pckPrefix, pckPrefix.length) == 0)
		{
			// Source directory has the form [package]:/MHost/Mhost/Graphics/Renderer.sxy
			cstr appendix = packagePath + pckPrefix.length;
			char* p = buf;
			char* end = buf + capacity;

			char* finalSlash = nullptr;

			for (cstr c = appendix; *c != 0 && p < end; ++c, p++)
			{
				if (*c == '/')
				{
					finalSlash = p;
					*p = '.';
				}
				else
				{
					*p = *c;
				}
			}

			if (finalSlash)
			{
				*finalSlash = 0; // That strips the file name
				// Now if we have space, append the .<name>
				SafeFormat(finalSlash, end - finalSlash, "%s", fqName + 1);
			}
			else
			{
				SafeFormat(buf, capacity, "%s defined by %s", fqName, packagePath);
			}
		}
		else
		{
			SafeFormat(buf, capacity, "%s defined by %s", fqName, packagePath);
		}
	}

	struct SxyFactory : ISXYFactory
	{
		SxyFactory(cstr name, ISXYFile& _source_file, cr_sex _sDef) :
			shortName(name), source_file(&_source_file), sDef(&_sDef), bodyIndicator(0)
		{
			// Factory expressions have the form (factory <name> <defined-interface> (arg1type arg1name) ...(argNtype argNname): ...)
			for (int i = 3; i < _sDef.NumberOfElements(); ++i)
			{
				if (Eq(AlwaysGetAtomic(_sDef, i), ":"))
				{
					bodyIndicator = i;
					break;
				}
			}

			if (!bodyIndicator) bodyIndicator = 3; // This is an error, but it is not currently the job of sexystudio to provide correction suggestions
		}

		cstr SourcePath() const override
		{
			return sDef->Tree().Source().Name();
		}

		cstr PublicName() const override
		{
			return shortName.c_str();
		}

		int InputCount() const override
		{
			return bodyIndicator - 3;
		}

		void GetDefinedInterface(char* buf, size_t capacity) const override
		{
			cstr fqInterfaceName = AlwaysGetAtomic(*sDef, 2);
			if (Compare(fqInterfaceName, "$.", 2) == 0)
			{
				ResolvePackageName(fqInterfaceName, buf, capacity, *sDef);
			}
			else
			{
				SafeFormat(buf, capacity, "%s", fqInterfaceName);
			}
		}

		cstr InputType(int index) const override
		{
			int i = 3 + index;
			cr_sex sInput = sDef->GetElement(i);
			return AlwaysGetAtomic(sInput, 0);
		}

		cstr InputName(int index) const  override
		{
			int i = 3 + index;
			cr_sex sInput = sDef->GetElement(i);
			return AlwaysGetAtomic(sInput, 1);
		}

		std::string shortName;
		ISXYFile* source_file;
		int bodyIndicator;
		const ISExpression* sDef;
	};

	struct SxyInterface: ISXYInterface
	{
		SxyInterface(cstr name, ISXYFile& _source_file, cr_sex _sInterfaceDef):
			shortName(name), source_file(&_source_file), sInterfaceDef(&_sInterfaceDef)
		{

		}

		cstr SourcePath() const override
		{
			return sInterfaceDef->Tree().Source().Name();
		}

		int AttributeCount() const override
		{
			return (int)attributes.size();
		}

		cstr GetAttribute(int index) const
		{
			return attributes[index].GetName();
		}

		cr_sex GetDefinition() const
		{
			return *sInterfaceDef;
		}

		int MethodCount() const override
		{
			return (int) methods.size();
		}

		ISXYFunction& GetMethod(int index) override
		{
			return methods[index];
		}

		cstr PublicName() const override
		{
			return shortName.c_str();
		}

		std::string shortName;
		ISXYFile* source_file;
		const ISExpression* sInterfaceDef;
		std::vector<SXYAttribute> attributes;
		const ISExpression* base = nullptr;
		cstr Base() const override
		{
			return base ? AlwaysGetAtomic(*base, 1) : nullptr;
		}
		std::vector<SXYMethod> methods;
	};

	struct SXYMacro
	{
		std::string shortName;
		ISXYFile& source_file;
		cr_sex sMacroDef;
		
		cstr GetMacroValue() const
		{
			// An enum looks like this (macro #Sys.IO.MaxFilePathLen in out (out.AddAtomic "0x102"))

			if (sMacroDef.NumberOfElements() == 5)
			{
				cr_sex sDirective = sMacroDef[4]; // (out.AddAtomic "0x102"))
				if (sDirective.NumberOfElements() == 2)
				{
					if (IsAtomic(sDirective[0]) && IsStringLiteral(sDirective[1]))
					{
						cstr s0 = sDirective[0].String()->Buffer;
						cstr s1 = sDirective[1].String()->Buffer;

						if (Eq(s0, "out.AddAtomic") && Compare(s1, "0x", 2) == 0)
						{
							return s1;
						}
					}
				}
			}

			return nullptr;
		}

	};

	struct SXYPublicFunction: ISXYPublicFunction
	{
		SXYPublicFunction(cstr _publicName, cstr _localName, ISXYFile& _file) :
			publicName(_publicName), localName(_localName), file(&_file)
		{

		}

		cstr PublicName() const override
		{
			return publicName.c_str();
		}

		std::string publicName;
		std::string localName;
		ISXYFile* file;

		ISXYFunction* localFunction = nullptr;

		ISXYFunction* LocalFunction() override
		{
			return localFunction;
		}
	};

	struct SXYStruct: ISXYLocalType
	{
		cr_sex sStructDef;
		int numberOfFields = 0;

		int FieldCount() const override { return numberOfFields; }

		SXYStruct(cr_sex _sStructDef) : sStructDef(_sStructDef)
		{
			// Assumes _StructDef.NumberOfElements > 0
			for (int i = 2; i < _sStructDef.NumberOfElements(); ++i)
			{
				cr_sex sFieldDef = _sStructDef[i];
				if (sFieldDef.NumberOfElements() > 1)
				{
					numberOfFields += sFieldDef.NumberOfElements() - 1;
				}
			}
		}

		cstr SourcePath() const
		{
			return sStructDef.Tree().Source().Name();
		}

		/* Example:
		(struct Quaternion
			(Float32 scalar)
			(Float32 vi vj vk)
		)
		*/
		SXYField GetField(int index) const override
		{
			if (index < 0 || index >= numberOfFields)
			{
				return SXYField{ nullptr, nullptr };
			}

			int fieldCount = 0;

			for (int i = 2; i < sStructDef.NumberOfElements(); ++i)
			{
				cr_sex sFieldDef = sStructDef[i];
				int nFieldsInExpression = sFieldDef.NumberOfElements() - 1;
				if (index < fieldCount + nFieldsInExpression)
				{
					cstr type = AlwaysGetAtomic(sFieldDef, 0);
					cstr name = AlwaysGetAtomic(sFieldDef, index - fieldCount + 1);
					return SXYField{ type,name };
				}
				else
				{
					fieldCount += nFieldsInExpression;
				}
			}

			return { nullptr,nullptr };
		}
	};

	struct SXYPublicStruct: ISXYType
	{
		std::string publicName;
		std::string localName;
		ISXYFile& file;
		ISXYLocalType* localType = nullptr;

		SXYPublicStruct(cstr _publicName, cstr _localName, ISXYFile& _file):
			publicName(_publicName), localName(_localName), file(_file)
		{

		}

		cstr PublicName() const override
		{
			return publicName.c_str();
		}

		ISXYLocalType* LocalType() override
		{
			return localType;
		}
	};

	struct SXYNSAlias
	{
		std::string publicName;
		sexstring fqName;
		cr_sex sAliasDef;
		ISXYFile& file;
	};

	// archetype expressions have the format (archetype <FQ_NAME> (arg-type1 arg-name1)...(arg-typeN arg-nameN)->(out-type1 out-name1)...(out-typeN out-nameN))
	struct SXYArchetype : ISXYArchetype
	{
		int mappingIndex = 0;

		SXYArchetype(cstr _publicName, ISXYFile& _file, cr_sex _sDef) :
			publicName(_publicName), sDef(_sDef), file(_file)
		{
			for (int i = 2; i < sDef.NumberOfElements(); ++i)
			{
				if (Eq(AlwaysGetAtomic(sDef, i), "->"))
				{
					mappingIndex = i;
					break;
				}
			}
		}

		cstr PublicName() const override
		{
			return publicName.c_str();
		}

		int InputCount() const override
		{
			return mappingIndex > 0 ? mappingIndex - 2 : 0;
		}

		int OutputCount() const override
		{
			return mappingIndex > 0 ? sDef.NumberOfElements() - mappingIndex - 1 : 0;
		}

		cstr InputType(int index) const override
		{
			auto& sArg = sDef[index + 2];
			return AlwaysGetAtomic(sArg, 0);
		}

		cstr OutputType(int index) const override
		{
			auto& sArg = sDef[mappingIndex + index + 1];
			return AlwaysGetAtomic(sArg, 0);
		}

		cstr InputName(int index) const override
		{
			auto& sArg = sDef[index + 2];
			return AlwaysGetAtomic(sArg, 1);
		}

		cstr OutputName(int index) const override
		{
			auto& sArg = sDef[mappingIndex + index + 1];
			return AlwaysGetAtomic(sArg, 1);
		}

		cstr SourcePath() const override
		{
			return sDef.Tree().Source().Name();
		}

		cr_sex sDef;
		std::string publicName;
		ISXYFile& file;
	};


	struct SxyNamespace : ISxyNamespace
	{
		std::string name;
		std::vector<std::unique_ptr<SxyNamespace>> subspaces;
		std::vector<SxyFactory> factories;
		std::vector<SxyInterface> interfaces;
		std::vector<SXYMacro> macros;
		std::vector<SXYMacro> enums;
		std::vector<SXYPublicFunction> functions;
		std::vector<SXYPublicStruct> structures;
		std::vector<SXYNSAlias> nsAlias;
		std::vector<SXYArchetype> archetypes;
		SxyNamespace* parent;

		SxyNamespace(cstr _name, SxyNamespace* _parent) : name(_name), parent(_parent) {}

		int AliasCount() const override
		{
			return (int) nsAlias.size();
		}

		cstr GetNSAliasFrom(int index) const override
		{
			return AlwaysGetAtomic(nsAlias[index].sAliasDef, 1);
		}

		cstr GetNSAliasTo(int index) const override
		{
			return nsAlias[index].publicName.c_str();
		}

		ISxyNamespace* GetParent() override
		{
			return parent;
		}

		cstr GetAliasSourcePath(int index) const override
		{
			return nsAlias[index].sAliasDef.Tree().Source().Name();
		}

		ISXYFactory& GetFactory(int index) override
		{
			return factories[index];
		}

		int FactoryCount() const override
		{
			return (int) factories.size();
		}

		int EnumCount() const override
		{
			return (int)enums.size();
		}

		cstr GetEnumName(int index) const override
		{
			return enums[index].shortName.c_str();
		}

		cstr GetEnumValue(int index) const override
		{
			return enums[index].GetMacroValue();
		}

		cstr GetEnumSourcePath(int index) const override
		{
			return enums[index].sMacroDef.Tree().Source().Name();
		}

		int Length() const override
		{
			return (int) subspaces.size();
		}

		int FunctionCount() const override
		{
			return (int)functions.size();
		}

		ISXYArchetype& GetArchetype(int index) override
		{
			return archetypes[index];
		}

		int ArchetypeCount() const override
		{
			return (int) archetypes.size();
		}

		ISXYPublicFunction& GetFunction(int index) override
		{
			return functions[index];
		}

		int InterfaceCount() const override
		{
			return (int) interfaces.size();
		}

		int TypeCount() const override
		{
			return (int)structures.size();
		}

		ISXYType& GetType(int index) override
		{
			return structures[index];
		}

		ISXYInterface& GetInterface(int index) override
		{
			return interfaces[index];
		}

		ISxyNamespace& operator[] (int index) override
		{
			if (index < 0 || index >= (int)subspaces.size())
			{
				Throw(0, "Bad namespace index");
			}

			return *subspaces[index];
		}

		cstr Name() override
		{
			return name.c_str();
		}

		// Creates or updates namespace tree by breaking a path such as MHost/Widgets into MHost & Widgets
		ISxyNamespace& MapPathToNamespace(cstr path)
		{
			cstr s = path;
			while (*s != '/' && *s != 0)
			{
				s++;
			}

			if (*s == 0)
			{
				if (EndsWith(path, ".sxy"))
				{
					return *this;
				}

				for (auto& sub : subspaces)
				{
					if (Eq(sub->Name(), path))
					{
						return *sub;
					}
				}

				subspaces.push_back(std::make_unique<SxyNamespace>(path, this));
				return *subspaces[subspaces.size() - 1];
			}
			else
			{
				char* prefix = (char*)alloca(s - path + 1);
				memcpy(prefix, path, s - path);
				prefix[s - path] = 0;

				for (auto& sub : subspaces)
				{
					if (Eq(sub->Name(), prefix))
					{
						return sub->MapPathToNamespace(s + 1);
					}
				}

				subspaces.push_back(std::make_unique<SxyNamespace>(prefix, this));
				return subspaces.back()->MapPathToNamespace(s + 1);
			}
		}

		ISxyNamespace& Update(cstr subspace, cr_sex src) override
		{
			if (Eq(subspace, "$"))
			{
				// The dollar indicates we generate the namespace from the file path
				cstr filename = src.Tree().Source().Name();

				if (Compare(filename, pckPrefix, pckPrefix.length) == 0)
				{
					filename += pckPrefix.length;
				}

				return MapPathToNamespace(filename);
			}

			for (auto& s : subspaces)
			{
				if (Eq(s->Name(), subspace))
				{
					return *s;
				}
			}

			subspaces.push_back(std::make_unique<SxyNamespace>(subspace, this));
			return *subspaces[subspaces.size() - 1];
		}

		void UpdateArchetype(cstr name, cr_sex sArchetypeDef, ISXYFile& file) override
		{
			archetypes.push_back({ name, file, sArchetypeDef });
		}

		void UpdateFactory(cstr name, cr_sex sFactoryDef, ISXYFile& file) override
		{
			factories.push_back({ name, file, sFactoryDef });
		}

		void UpdateInterface(cstr name, cr_sex sInterfaceDef, ISXYFile& file) override
		{
			interfaces.push_back( { name, file, sInterfaceDef } );
			auto& interf = interfaces.back();
			for (int i = 2; i < sInterfaceDef.NumberOfElements(); ++i)
			{
				auto& sChild = sInterfaceDef[i];
				if (sInterfaceDef.NumberOfElements() >= 2)
				{
					cstr child = AlwaysGetAtomic(sChild, 0);
					if (IsCapital(child[0]))
					{
						// methods have capital letters
						// example (AppendPrefixAndGetName (IString prefix)->(IString name))
						interf.methods.push_back(sChild);
					}
					else if (Eq(child, "attribute"))
					{
						interf.attributes.push_back( { &sChild  } );
					}
					else if (Eq(child, "extends"))
					{
						// base interface
						interf.base = &sChild;
					}
				}
			}

			std::sort(interf.methods.begin(), interf.methods.end(), 
				[](const SXYMethod& a, const SXYMethod& b)
				{
					return Compare(a.name, b.name) < 0;
				}
			);
		}

		void UpdateInterfaceViaDefinition(cstr interfacePublicName, cr_sex sClassDef, ISXYFile& file) override
		{
			interfaces.push_back({ interfacePublicName, file, sClassDef });

			sexstring className = sClassDef[1].String();

			auto& interf = interfaces.back();
			for (int i = 2; i < sClassDef.NumberOfElements(); ++i)
			{
				auto& sChild = sClassDef[i];
				if (sClassDef.NumberOfElements() >= 2)
				{
					cstr child = AlwaysGetAtomic(sChild, 0);
					if (Eq(child, "attribute"))
					{
						interf.attributes.push_back({ &sChild });
					}
					else if (Eq(child, "extends"))
					{
						// base interface
						interf.base = &sChild;
					}
				}
			}

			cr_sex sRoot = sClassDef.Tree().Root();
			for (int i = 0; i < sRoot.NumberOfElements(); ++i)
			{
				cr_sex sMethod = sRoot[i];
				if (sMethod.NumberOfElements() >= 4)
				{
					// methods are expressed thus: (method <class-name>.<method-name> [inputs] -> [outputs]: [body])
					if (Eq(AlwaysGetAtomic(sMethod, 0), "method"))
					{
						if (IsAtomic(sMethod[1]))
						{
							sexstring classAndMethod = sMethod[1].String();

							auto* dot = FindDot(classAndMethod->Buffer);
							if (*dot == '.')
							{
								if (dot - classAndMethod->Buffer == className->Length)
								{
									if (Compare(classAndMethod->Buffer, className->Buffer, className->Length) == 0)
									{
										// We have a class match for <class-name>.<method-name>
										cstr methodName = dot + 1;
										if (*methodName && !Eq(methodName, "Construct") && !Eq(methodName, "Destruct"))
										{
											interf.methods.push_back({ sMethod, true });
										}
									}
								}
							}
						}
					}
				}
			}

			std::sort(interf.methods.begin(), interf.methods.end(),
				[](const SXYMethod& a, const SXYMethod& b)
				{
					return Compare(a.name, b.name) < 0;
				}
			);
		}

		void UpdateMacro(cstr name, cr_sex sMacroDef, ISXYFile& file) override
		{
			SXYMacro macro { name, file, sMacroDef };
			if (macro.GetMacroValue() == nullptr)
			{
				macros.push_back(macro);
			}
			else
			{
				enums.push_back(macro);
			}
		}

		void SortRecursive() override
		{
			std::sort(subspaces.begin(), subspaces.end(),
				[](const std::unique_ptr<SxyNamespace>& a, const std::unique_ptr<SxyNamespace>& b)->bool
				{
					return a->name < b->name;
				}
			);

			std::sort(functions.begin(), functions.end(),
				[](const SXYPublicFunction& a, const SXYPublicFunction& b)->bool
				{
					return Compare(a.PublicName(), b.PublicName()) < 0;
				}
			);
			
			std::sort(factories.begin(), factories.end(),
				[](const SxyFactory& a, const SxyFactory& b)->bool
				{
					return Compare(a.PublicName(), b.PublicName()) < 0;
				}
			);

			std::sort(interfaces.begin(), interfaces.end(),
				[](const SxyInterface& a, const SxyInterface& b)->bool
				{
					return Compare(a.PublicName(), b.PublicName()) < 0;
				}
			);

			for (auto& subspace : subspaces)
			{
				subspace->SortRecursive();
			}
		}

		void AliasFunction(cstr localName, ISXYFile& file, cstr publicName) override
		{
			functions.push_back({publicName, localName, file});
		}

		void AliasStruct(cstr localName, ISXYFile& file, cstr publicName) override
		{
			structures.push_back({ publicName, localName, file });
		}

		void AliasNSREf(cstr publicName, cr_sex sAliasDef, ISXYFile& file) override
		{
			nsAlias.push_back({ publicName, sAliasDef[2].String(), sAliasDef, file});
		}
	};

	struct SXYFunction: ISXYFunction
	{
		cr_sex sFunction;
		cstr name = nullptr;
		int mapIndex = -1;
		int bodyIndex = -1;

		cstr SourcePath() const override
		{
			return sFunction.Tree().Source().Name();
		}

		cstr PublicName() const override
		{
			return name;
		}

		int InputCount() const override
		{
			return mapIndex < 0 ? 0 : mapIndex - 2;
		}

		int OutputCount() const override
		{
			return bodyIndex - mapIndex - 1;
		}

		cstr InputType(int index) const override
		{
			cr_sex sArg = sFunction.GetElement(index + 2);
			return AlwaysGetAtomic(sArg, 0);
		}

		cstr OutputType(int index) const override
		{
			cr_sex sArg = sFunction.GetElement(index + mapIndex + 1);
			return AlwaysGetAtomic(sArg, 0);
		}

		cstr InputName(int index) const override
		{
			cr_sex sArg = sFunction.GetElement(index + 2);
			return AlwaysGetAtomic(sArg, 1);
		}

		cstr OutputName(int index) const override
		{
			cr_sex sArg = sFunction.GetElement(index + mapIndex + 1);
			return AlwaysGetAtomic(sArg, 1);
		}

		SXYFunction(cr_sex _sFunction) : sFunction(_sFunction)
		{
			name = AlwaysGetAtomic(_sFunction, 1);

			for (int i = 1; i < _sFunction.NumberOfElements(); ++i)
			{
				if (IsAtomic(_sFunction[i]))
				{
					cstr arg = _sFunction[i].String()->Buffer;
					if (mapIndex < 0)
					{
						if (Eq(arg, "->"))
						{
							mapIndex = i;
						}
					}
					else // map index defined and the next legal atomic argument is ':' the body indicator
					{
						if (Eq(arg, ":"))
						{
							bodyIndex = i;
							break;
						}
					}
				}
			}
		}

		int GetBeginInputIndex() const
		{
			return 2;
		}

		int GetEndIndexIndex() const
		{
			return mapIndex < 0 ? 1 : mapIndex;
		}

		int GetBeginOutputIndex() const
		{
			return mapIndex + 1;
		}

		int GetEndOutputIndex() const
		{
			return mapIndex < 0 ? 0 : bodyIndex;
		}

		SXYMethodArgument GetArg(int index) const
		{
			auto& sArg = sFunction[index];
			if (sArg.NumberOfElements() == 2)
			{
				if (IsAtomic(sArg[0]) && IsAtomic(sArg[1]))
				{
					return { sArg[0].String()->Buffer, sArg[1].String()->Buffer };
				}
			}

			return { nullptr, nullptr };
		}
	};

	struct File_SXY: ISXYFile
	{
		File_SXY(const std::string& _filename): filename(_filename)
		{

		}

		stringmap<SXYStruct> structures;
		stringmap<SXYFunction> functions;

		int errorCode = 0;
		std::string errorMessage;
		uint64 fileLength = 0;
		std::string filename;
		AutoRelease<ISParserTree> s_tree;
	};

	void CopyFinalNameToBuffer(char* buffer, size_t capacity, cstr fqName)
	{
		cstr s = fqName;
		while (*s != 0) s++;

		while (s > fqName)
		{
			if (*s == '.')
			{
				strcpy_s(buffer, capacity, s + 1);
				return;
			}

			s--;
		}

		if (buffer && capacity) *buffer = 0;
	}

	struct SexyDatabase : ISexyDatabaseSupervisor
	{
		AutoRelease<ISParser> sparser;
		ANON::SxyNamespace rootNS;

		std::unordered_map<std::string, std::unique_ptr<File_SXY>> filenameToFile;

		SexyDatabase(): 
			sparser(Sexy_CreateSexParser_2_0(Rococo::Memory::CheckedAllocator())),
			rootNS("", nullptr)
		{

		}

		~SexyDatabase()
		{
			
		}

		ISxyNamespace& GetRootNamespace()
		{
			return rootNS;
		}

		void ResolveRecursive(SxyNamespace& ns)
		{
			for (auto& s : ns.structures)
			{
				File_SXY& source = static_cast<File_SXY&>(s.file);
				auto i = source.structures.find(s.localName.c_str());
				if (i != source.structures.end())
				{
					s.localType = &i->second;
				}
			}

			for (auto& f : ns.functions)
			{
				File_SXY& source = static_cast<File_SXY&>(*f.file);
				auto i = source.functions.find(f.localName.c_str());
				if (i != source.functions.end())
				{
					f.localFunction = &i->second;
				}
			}

			for (auto& subspace: ns.subspaces)
			{
				ResolveRecursive(*subspace);
			}
		}

		void Sort() override
		{
			rootNS.SortRecursive();
			ResolveRecursive(rootNS);
		}

		ISParserTree* TryGetTree(int& errorCode, char* errorBuffer, size_t errorCapacity, cstr filename)
		{
			auto i = filenameToFile.find(filename);
			if (i == filenameToFile.end())
			{
				errorCode = 0;
				if (errorBuffer) SafeFormat(errorBuffer, errorCapacity, "No such file: %s", filename);
				return nullptr;
			}
			else
			{
				auto& file = *i->second;
				if (!file.s_tree)
				{
					errorCode = file.errorCode;
					if (errorBuffer) SafeFormat(errorBuffer, errorCapacity, "%s", file.errorMessage.c_str());
					return nullptr;
				}
			}
		}

		void UpdateFile_SXY_PackedItem(cstr data, int32 length, cstr path) override
		{
			std::string filename = path;
			auto i = filenameToFile.find(filename);
			if (i == filenameToFile.end())
			{
				i = filenameToFile.insert(std::make_pair(filename, new File_SXY(filename))).first;
				auto& file = *i->second;

				U8FilePath name;
				SafeFormat(name.buf, "[package]:%hs", path);

				AutoRelease<ISourceCode> src;

				try
				{
					src = sparser->DuplicateSourceBuffer(data, length, { 1,1 }, name);
				}
				catch (IException& ex)
				{
					file.errorCode = ex.ErrorCode();
					file.errorMessage = ex.Message();
					return;
				}

				try
				{
					file.s_tree = sparser->CreateTree(*src);
					file.fileLength = file.s_tree->Source().SourceLength();
				}
				catch (IException& ex)
				{
					file.errorCode = ex.ErrorCode();
					file.errorMessage = ex.Message();
				}
			}

			if (i->second->s_tree)
			{
				ParseTree(*i->second->s_tree, *i->second);
			}
		}

		void UpdateFile_SXY(cstr fullpathToSxy) override
		{
			std::string filename = fullpathToSxy;
			auto i = filenameToFile.find(filename);
			if (i == filenameToFile.end())
			{
				i = filenameToFile.insert(std::make_pair(filename, new File_SXY(filename))).first;
				auto& file = *i->second;

				uint64 len = GetFileLength(fullpathToSxy);

				if (len > 1_megabytes)
				{
					file.errorCode = 0;
					file.errorMessage = "File too large";
				}
				else
				{
					WideFilePath wPath;
					Assign(wPath, fullpathToSxy);

					AutoRelease<ISourceCode> src;

					try
					{
						src = sparser->LoadSource(wPath, { 1,1 });
					}
					catch (IException& ex)
					{
						file.errorCode = ex.ErrorCode();
						file.errorMessage = ex.Message();
						return;
					}

					try
					{
						file.s_tree = sparser->CreateTree(*src);
						file.fileLength = file.s_tree->Source().SourceLength();
					}
					catch (ParseException& pex)
					{
						file.errorCode = pex.ErrorCode();
						file.errorMessage = pex.Message();
					}
					catch (IException& ex)
					{
						file.errorCode = ex.ErrorCode();
						file.errorMessage = ex.Message();
					}
				}
			}

			if (i->second->s_tree)
			{
				ParseTree(*i->second->s_tree, *i->second);
			}
		}

		void Clear() override
		{
			filenameToFile.clear();
			rootNS.subspaces.clear();
			rootNS.enums.clear();
			rootNS.functions.clear();
			rootNS.structures.clear();
			rootNS.interfaces.clear();
		}

		void Free() override
		{
			delete this;
		}

		void NPP_AppendAllChildrenFromRoot(ISxyNamespace& ns, StringBuilder& sb)
		{
			sb << "    <KeyWord name = \"";
			AppendFullName(ns, sb);
			sb << "\">\n";

			for (int i = 0; i < ns.Length(); ++i)
			{
				NPP_AppendAllChildrenFromRoot(ns[i], sb);
			}

			for (int i = 0; i < ns.FunctionCount(); ++i)
			{
				sb << "    <KeyWord name = \"";

				AppendFullName(ns, sb);
				sb << ".";
				sb << ns.GetFunction(i).PublicName();
				sb << "\">\n";
			}
		}

		void NPP_GenerateAutocompleteFile(const wchar_t* targetFullPath) override
		{
			AutoFree<IStringBuilder> dsb = CreateDynamicStringBuilder(4096);
			auto& sb = dsb->Builder();

			sb << "<? xml version = \"1.0\" encoding = \"UTF - 8\" ?>\n";

			sb << "<NotepadPlus>\n";
			sb << "  <AutoComplete>\n";

			auto& root = GetRootNamespace();
			for (int i = 0; i < root.Length(); ++i)
			{
				NPP_AppendAllChildrenFromRoot(root[i], sb);
			}

			sb << "  </AutoComplete>\n";
			sb << "</NotepadPlus>\n";

			AutoFree<Rococo::IO::IBinaryArchive> archive = Rococo::IO::CreateNewBinaryFile(targetFullPath);
			archive->Write(1, sb.Length(), (*sb).buffer);			
		}

		ISxyNamespace& InsertNamespaceRecursive(cstr ns, ISxyNamespace& parent, cr_sex src)
		{
			cstr nsIndex = FindDot(ns);
			
			char* subspace = (char*) _alloca(nsIndex - ns + 1);
			memcpy(subspace, ns, nsIndex - ns);
			subspace[nsIndex - ns] = 0;

			auto& branch = parent.Update(subspace, src);

			if (*nsIndex == 0)
			{
				// No more work to do
				return branch;
			}
			else
			{
				// We still have subspaces after the dot
				return InsertNamespaceRecursive(nsIndex+1, branch, src);
			}
		}

		ISxyNamespace& InsertNamespaceRecursiveSANSEnd(cstr ns, ISxyNamespace& parent, cr_sex src)
		{
			cstr nsIndex = FindDot(ns);

			if (*nsIndex == 0)
			{
				return parent;
			}

			char subspace[256];
			if (nsIndex - ns >= 255)
			{
				// Namespace too long
				return parent;
			}

			memcpy(subspace, ns, nsIndex - ns);
			subspace[nsIndex - ns] = 0;
			auto& branch = parent.Update(subspace, src);
			return InsertNamespaceRecursiveSANSEnd(nsIndex + 1, branch, src);
		}

		void InsertNamespaceUnique(cr_sex s, cstr ns, File_SXY& file)
		{
			InsertNamespaceRecursive(ns, rootNS, s);
		}

		void InsertInterfaceRecursive(cstr ns, ISxyNamespace& parent, File_SXY& file, cr_sex sInterfaceDef)
		{
			cstr nsIndex = FindDot(ns);

			if (*nsIndex == '.')
			{
				char* subspace = (char*)_alloca(nsIndex - ns + 1);
				memcpy(subspace, ns, nsIndex - ns);
				subspace[nsIndex - ns] = 0;

				auto& branch = parent.Update(subspace, sInterfaceDef);
				InsertInterfaceRecursive(nsIndex + 1, branch, file, sInterfaceDef);
			}
			else
			{
				parent.UpdateInterface(ns, sInterfaceDef, file);
			}
		}

		void InsertArchetype(cr_sex s, const fstring& archetypeName, File_SXY& file)
		{
			char* publicName = (char*)_alloca(archetypeName.length + 1);
			CopyFinalNameToBuffer(publicName, archetypeName.length + 1, archetypeName);
			ISxyNamespace& ns = InsertNamespaceRecursiveSANSEnd(archetypeName, rootNS, s);
			ns.UpdateArchetype(publicName, s, file);
		}

		void InsertClass(cr_sex s, const fstring& className, File_SXY& file)
		{
			for (int i = 2; i < s.NumberOfElements(); ++i)
			{
				cr_sex sArg = s[i];
				if (sArg.NumberOfElements() == 2)
				{
					if (Eq(AlwaysGetAtomic(sArg, 0), "defines"))
					{
						if (IsAtomic(sArg[1]))
						{
							auto strFqName = sArg[1].String();
							cstr fqName = strFqName->Buffer;
							char* publicName = (char*)_alloca(strFqName->Length + 1);
							CopyFinalNameToBuffer(publicName, strFqName->Length + 1, fqName);
							ISxyNamespace& ns = InsertNamespaceRecursiveSANSEnd(fqName, rootNS, s);
							ns.UpdateInterfaceViaDefinition(publicName, s, file);
						}
					}
				}
			}
		}

		void InsertFactory(cr_sex s, const fstring& factoryName, const fstring& factoryInterface, File_SXY& file)
		{
			char* publicName = (char*)_alloca(factoryName.length + 1);
			CopyFinalNameToBuffer(publicName, factoryName.length + 1, factoryName);
			ISxyNamespace& ns = InsertNamespaceRecursiveSANSEnd(factoryName, rootNS, s);
			ns.UpdateFactory(publicName, s, file);
		}

		void InsertInterface(cr_sex s, const fstring& fqName, File_SXY& file)
		{
			char* publicName = (char*)_alloca(fqName.length + 1);
			CopyFinalNameToBuffer(publicName, fqName.length + 1, fqName);
			ISxyNamespace& ns = InsertNamespaceRecursiveSANSEnd(fqName, rootNS, s);
			ns.UpdateInterface(publicName, s, file);
		}

		void InsertStruct(cr_sex s, const fstring& structName, File_SXY& file)
		{
			file.structures.insert(structName, SXYStruct(s));
		}

		void InsertFunction(cr_sex s, const fstring& fnName, File_SXY& file)
		{
			file.functions.insert(fnName, SXYFunction(s));
		}

		void InsertMacroRecursive(cstr ns, ISxyNamespace& parent, File_SXY& file, cr_sex sMacroDef)
		{
			cstr nsIndex = FindDot(ns);

			if (*nsIndex == '.')
			{
				char* subspace = (char*)_alloca(nsIndex - ns + 1);
				memcpy(subspace, ns, nsIndex - ns);
				subspace[nsIndex - ns] = 0;

				auto& branch = parent.Update(subspace, sMacroDef);
				InsertMacroRecursive(nsIndex + 1, branch, file, sMacroDef);
			}
			else
			{
				parent.UpdateMacro(ns, sMacroDef, file);
			}
		}

		void InsertMacro(cr_sex s, const fstring& fqMacroName, File_SXY& file)
		{
			InsertMacroRecursive(fqMacroName, rootNS, file, s);
		}

		void InsertAlias(cr_sex s, const fstring& aliasFrom, const fstring& aliasTo, File_SXY& file)
		{
			// We have two sorts of alias: 
			//     1) from one namespace to another (alias Sys.Type.Float32 Sys.OpenGL.GLfloat)
			//     2) a local object to a namespace (alias Main EntryPoint.Main)

			char* publicName = (char*)_alloca(aliasTo.length + 1);
			CopyFinalNameToBuffer(publicName, aliasTo.length + 1, aliasTo);

			if (*publicName == 0)
			{
				// Error, the alias was not fully qualified - X.Y.PublicName
				return;
			}

			cstr dot = FindDot(aliasFrom);

			if (*dot == '.')
			{
				// A namespace mapping
				ISxyNamespace& ns = InsertNamespaceRecursiveSANSEnd(aliasTo, rootNS, s);
				ns.AliasNSREf(publicName, s, file);
			}
			else
			{
				// A local object published in the target namespace
				auto i = file.functions.find(aliasFrom);
				if (i != file.functions.end())
				{
					ISxyNamespace& ns = InsertNamespaceRecursiveSANSEnd(aliasTo, rootNS, s);
					ns.AliasFunction(aliasFrom, file, publicName);
				}

				auto j = file.structures.find(aliasFrom);
				if (j != file.structures.end())
				{
					ISxyNamespace& ns = InsertNamespaceRecursiveSANSEnd(aliasTo, rootNS, s);
					ns.AliasStruct(aliasFrom, file, publicName);
				}
			}
		}

		void ParseTree(ISParserTree& tree, File_SXY& file)
		{
			cr_sex sRoot = tree.Root();

			// First build up a list of objects in the sxy file
			for (int i = 0; i < sRoot.NumberOfElements(); ++i)
			{
				if (match_compound(sRoot[i], 2, keywordNamespace, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& nsText)
					{
						InsertNamespaceUnique(s, nsText, file);
					}
				)) continue;

				enum { MAX_METHODS_AND_ATTRIBUTES_PER_INTERFACE = 32766 };
				if (match_compound(sRoot[i], MAX_METHODS_AND_ATTRIBUTES_PER_INTERFACE, keywordInterface, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& fqName)
					{
						InsertInterface(s, fqName, file);
					}
				)) continue;

				enum { MAX_FIELDS_PER_STRUCT = 32766 };
				if (match_compound(sRoot[i], MAX_FIELDS_PER_STRUCT, keywordStruct, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& structName)
					{
						InsertStruct(s, structName, file);
					}
				)) continue;

				enum { MAX_ARGS_PER_FUNCTION = 128 };
				if (match_compound(sRoot[i], MAX_ARGS_PER_FUNCTION, keywordFunction, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& fnName)
					{
						InsertFunction(s, fnName, file);
					}
				)) continue;

				enum { MAX_ARGS_PER_MACRO = 128 };
				if (match_compound(sRoot[i], MAX_ARGS_PER_MACRO, keywordMacro, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& macroName)
					{
						InsertMacro(s, macroName, file);
					}
				)) continue;


				// Example (factory $.NewUIStack $.IUIStack : (construct UIStack))
				enum { MAX_ARGS_PER_FACTORY = 128 };
				if (match_compound(sRoot[i], MAX_ARGS_PER_FACTORY, keywordFactory, ParseAtomic, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& factoryName, const fstring& factoryInterface)
					{
						InsertFactory(s, factoryName, factoryInterface, file);
					}
				)) continue;

				// Example (archetype $.name (arg1 <name1>)...(argN <nameN>)->(out1 <name1>)...(outN <nameN>))
				enum { MAX_ARGS_PER_ARCHETYPE = 128 };
				if (match_compound(sRoot[i], MAX_ARGS_PER_ARCHETYPE, keywordArchetype, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& archetypeName)
					{
						InsertArchetype(s, archetypeName, file);
					}
				)) continue;

				// Example (class Dog (defines Sys.IDog) ...))
				enum { MAX_ARGS_PER_CLASS_DEFINITION = 1024 };
				if (match_compound(sRoot[i], MAX_ARGS_PER_CLASS_DEFINITION, keywordClass, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& localClassName)
					{
						InsertClass(s, localClassName, file);
					}
				)) continue;
			}

			// Then compute the aliases
			for (int i = 0; i < sRoot.NumberOfElements(); ++i)
			{
				enum { MAX_ALIAS_LEN = 3 };
				match_compound(sRoot[i], MAX_ALIAS_LEN, keywordAlias, ParseAtomic, ParseAtomic,
					[this, &file](cr_sex s, const fstring& sKeyword, const fstring& aliasFrom, const fstring& aliasTo)
					{
						InsertAlias(s, aliasFrom, aliasTo, file);
					}
				);
			}
		}
	};
}

namespace Rococo::SexyStudio
{
	ISexyDatabaseSupervisor* CreateSexyDatabase()
	{
		return new ANON::SexyDatabase();
	}

	void AppendFullName(ISxyNamespace& ns, StringBuilder& sb)
	{
		std::vector<cstr> genealogy;

		for (ISxyNamespace* i = &ns; i != nullptr; i = i->GetParent())
		{
			genealogy.push_back(i->Name());
		}

		// The final namespace is the root which has no name
		genealogy.pop_back();

		int depth = 0;

		for (auto i = genealogy.rbegin(); i != genealogy.rend(); i++, depth++)
		{
			if (depth > 0)
			{
				sb << ".";
			}

			sb << *i;
		}
	}
}