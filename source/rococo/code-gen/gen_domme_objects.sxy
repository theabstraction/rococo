(' #include "!scripts/sexml-reader.sxy" "!scripts/Sys/Type/Strings/StringMatch.sxy")


(namespace EntryPoint)

(alias Main EntryPoint.Main)

(using Sys.IO)
(using Sys.Type)

(function GetCmd (IString key) -> (IString result):
	(IStringBuilder candidate = NewPathBuilder)
	(IStringBuilder value = NewPathBuilder)
	(for (Int32 i = 0)(i < Sys.IO.GetCmdArgCount)(i += 1)
		(candidate.Clear) // Note - code complete did not add IStringBuilder methods
		(value.Clear)
		(Sys.IO.AppendCmdKeyAndValue i candidate value)
		(if ((Sys.Type.Strings.CompareInsensitive key candidate) == 0)
			(result = value)
			(return)
		)
	)
)

(function NamespaceConvertSxyToCpp (IString sxyNamespace) -> (IString cppNamespace):
	(IStringBuilder sb = (Sys.Type.NewStringBuilder 256))
	(sb sxyNamespace)
	(sb.Replace 0 "." "::")
	(cppNamespace = sb)
)

// Examples: Dog gets converted to dog. apple would remain as apple
(function ToCamelCase (IString pascalCase) -> (IString camelCase):
	(IStringBuilder sb = (Sys.Type.NewStringBuilder (pascalCase.Length + 1)))
	(sb pascalCase)
	(sb.ToLower 0 0)
	(camelCase = sb)
)

(struct DommeContext
	(Sys.Type.IStringBuilder cppBuilder)
	(Sys.Type.IStringBuilder headerBuilder)
	(IString factoryPrefix)
)

(function AssertCompound (Sys.Reflection.IExpression s)(IString exMessage) -> :
	(if (s.Type != (#Sys.Reflection.ExpressionTypeCompound))
		(
			(#paragraph msg "Expecting compound expression: " exMessage)
			(s.Throw 0 msg)
		)
	)
)

(function GetAtomicWithAssert  (Sys.Reflection.IExpression s)(Int32 childIndex)(IString exMessage) -> (IString value):
	(Sys.Reflection.IExpression child = (s.Child childIndex))
	(if (not (child ?))
		(
			(#paragraph msg "No child at position " childIndex ": " exMessage)
			(child.Throw 0 msg)
		)
	)
	
	(if (child.Type != (#Sys.Reflection.ExpressionTypeAtomic))
		(
			(#paragraph msg "Expecting atomic expression: " exMessage)
			(child.Throw 0 msg)
		)
	)
	
	(child.Text -> value)
)

(function BuildDommeObjectCPP (DommeContext dc) (Sys.Sexml.ISEXMLDirective domme) -> :
	(IString sxyNamespace = (domme.GetAttributeString "SxyNamespace" true))
	(IString cppNamespace = (NamespaceConvertSxyToCpp sxyNamespace))
	
	(Sys.Sexml.ISEXMLDirectiveList dommeSubdirectives = domme.SubDirectives)
	
	(Sys.Sexml.ISEXMLDirective interfaceDirective = (dommeSubdirectives.GetFirstDirective "Interface" true))
	
	(IString interfaceName = (interfaceDirective.GetAttributeString "Name" true))
	(IString implementationClass = (interfaceDirective.GetAttributeString "Implementation" true))
	
	(Sys.Type.IStringBuilder sb = dc.cppBuilder)
			
	(#build sb "namespace " cppNamespace "::Implementation&n")
	
	(sb "{&n")
	(#build sb "&tstruct " implementationClass " : " interfaceName "Supervisor&n")
	(sb "&t{&n")
	(sb "&t&tDommeObject D;&n&n")
	
	(#build sb "&t&t" implementationClass "(ScriptingResources& _scripting, cstr sourceName) : D(_scripting, sourceName, &"" interfaceName "&")&n")
	(sb "&t&t{&n")
	
	(Sys.Sexml.ISEXMLAttribute methods = (interfaceDirective.FindAttribute "Methods"))
		
	// (' Methods ...)
	(Sys.Reflection.IExpression sMethods = methods.S)
	(for (Int32 i = 2)(i < sMethods.ChildCount)(i += 1)
		(Sys.Reflection.IExpression sMethod = (sMethods.Child i))
		(AssertCompound sMethod "Method spec - (Method-Name (input1...)(input2...)->(return-expression)). void methods omit the output indicator '->' and the return-expression")
		
		(IString methodName = (GetAtomicWithAssert sMethod 0 "Expecting method name"))
		(IString methodVariableName = (ToCamelCase methodName))		
		
		(#build sb "&t&t&t" methodVariableName "Index = D.GetMethodIndex(&"" methodName "&", 1, 0);&n")
	)
	
	(sb "&t&t}&n&n")
	
	(#build sb "&t&t&~" implementationClass "()&n")
	(sb "&t&t{&n")
	(sb "&t&t}&n&n&n")
	
	(sb "&t&tvoid Free() override&n")
	(sb "&t&t{&n")
	(sb "&t&t&tdelete this;&n")
	(sb "&t&t}&n")
	
	(for (i = 2)(i < sMethods.ChildCount)(i += 1)
		(Sys.Reflection.IExpression sMethod = (sMethods.Child i))
		(AssertCompound sMethod "Method spec - (Method-Name (input1...)(input2...)->(return-expression)). void methods omit the output indicator '->' and the return-expression")
		
		(IString methodName = (GetAtomicWithAssert sMethod 0 "Expecting method name"))
		(IString methodVariableName = (ToCamelCase methodName))		
		
		(#build sb "&n&t&tint " methodVariableName "Index = -1;&n&n")
		
		(IStringBuilder args = (Sys.Type.NewStringBuilder 256))

		(BuildMethodArgsCPP methodName sMethod args false)
		
		(#build sb "&t&t" args " override&n")
		(sb "&t&t{&n")

		(#build sb "&t&t&tD.CallVirtualMethod(" methodVariableName "Index);&n")
		(sb "&t&t}&n")
	)
	
	(sb "&t};&n")
	(sb "}&n&n")
	
	(#build sb "namespace " cppNamespace "&n")
	(sb "{&n")
	(#build sb "&t" interfaceName "Supervisor* " dc.factoryPrefix implementationClass "(ScriptingResources& scripting, cstr sourceFile)&n")
	(sb "&t{&n")
	(#build sb "&t&treturn new Implementation::" implementationClass "(scripting, sourceFile);&n")
	(sb "&t}&n")
	(sb "}&n&n")
)

(function GetFirstChar (IString s) -> (Int32 codePoint):
	(codePoint = (s 0))
)

(function EscapeCPPString (Sys.Type.IStringBuilder argBuilder)(IString s)(Sys.Reflection.IExpression source) -> :
	(argBuilder "&"")
	
	(argBuilder.SetFormat 2 2 true false)
	
	(for (Int32 i = 0)(i < s.Length)(i += 1)
		(Int32 codePoint = (s i))
		
		(#Sys.Type.Strings.CharMatch codePoint
			("&"" (argBuilder "\&""))
			("\" (argBuilder "\\"))
			("&r" (argBuilder "\r"))
			("&n" (argBuilder "\n"))
			("&t" (argBuilder "\t"))
		else
			(if (codePoint >= 32)
				(argBuilder.AppendChar codePoint)
			else				
				(argBuilder "\x")
				(argBuilder Sys.Type.Formatters.Hex)
				(argBuilder codePoint)
			)
		)
	)
	
	(argBuilder "&"")
)

(function BuildMethodInputArgCPP (Sys.Reflection.IExpression sParameter)(Sys.Type.IStringBuilder argBuilder)(Bool includeDefaultValues)-> :

	(Bool expectingType = true)
	(Bool expectingName = true)
	(Bool expectingDefaultAssignment = true)

	(for (Int32 i = 0)(i < sParameter.ChildCount)(i += 1)
		(IString q = (GetAtomicWithAssert sParameter i "Expecting atomic qualifier to method argument"))
		(Sys.Reflection.IExpression sQ = (sParameter i))
		
		(if (Sys.Type.Strings.IsExactMatch q "const")
			(argBuilder "const ")
		else
			(if expectingType
				(expectingType = false)
				(argBuilder q)
			
			else 
				(if expectingName
					(expectingName = false)
					(argBuilder " ")
					(argBuilder q)
				
				else
					(if (not includeDefaultValues)
						(return)
					)
					
					(if expectingDefaultAssignment
						(if (Sys.Type.Strings.IsExactMatch q "=")
							(expectingDefaultAssignment = false)
							(argBuilder " = ")
							(Sys.Reflection.IExpression sDefault = (sParameter (i + 1)))
							(if (not (sDefault ?))
								(sQ.Throw 0 "Expecting default value to follow the assignment operator")
							)
							
							(if (sDefault.Type == (#Sys.Reflection.ExpressionTypeAtomic))
								(argBuilder sDefault.Text)
							else 
								(if (sDefault.Type == (#Sys.Reflection.ExpressionTypeString))
									(EscapeCPPString argBuilder sDefault.Text sDefault)
								else
									(sDefault.Throw 0 "Expecting atomic or string literal as the default value")
								)
							)
							
							(break)
							
						else
							(sQ.Throw 0 "Expecting assignment operator '=' to follow the variable name")
						)
					)
				)
			)
		)
	)
)

(function BuildMethodOutputArgCPP (Sys.Reflection.IExpression sParameter)(Sys.Type.IStringBuilder argsBuilder)-> :
	(if (not (sParameter ?))
		(argsBuilder "void")
	)
	
	(if (sParameter.ChildCount != 2)
		(sParameter.Throw 0 "Expecting two arguments to the output specification (<type> <name>. C++ will use the name as a comment, while sxy will use it to name the output parameter")
	)
	
	(Sys.Reflection.IExpression sOutputType = (sParameter 0))
	(Sys.Reflection.IExpression sOutputName = (sParameter 1))
	
	(IString type = (GetAtomicWithAssert sParameter 0 "<type> must be an atomic expression"))
	(IString name = (GetAtomicWithAssert sParameter 1 "<name> must be an atomic expression"))
	
	(#build argsBuilder type " /* " name " */")
)

(function IsAtomicMatch (Sys.Reflection.IExpression s)(IString target) -> (Bool isMatch):
	(if (s.Type == (#Sys.Reflection.ExpressionTypeAtomic))
		(Sys.Type.Strings.IsExactMatch s.Text target -> isMatch)
	)
)

(function FindTopLevelAtomic (Sys.Reflection.IExpression s)(IString target) -> (Int32 index):
	(for (Int32 i = 0)(i < s.ChildCount)(i += 1)
		(Sys.Reflection.IExpression child = (s i))
		(if (IsAtomicMatch child target)
			(index = i)
			(return)
		)
	)
	
	(index = -1)
)

(function BuildMethodArgsCPP (IString name) (Sys.Reflection.IExpression sMethod)(Sys.Type.IStringBuilder argsBuilder)(Bool includeDefaultValues)-> :
	
	// (<method-name> (<qualifiers>... <type> <variable-name> = <default>) ... -> (<qualifiers> <return-type> <variable-name>))
	
	(Int32 outputIndicator = (FindTopLevelAtomic sMethod "->"))
	
	(if (outputIndicator > -1)
		(Sys.Reflection.IExpression outParameter = (sMethod (outputIndicator + 1)))
		(BuildMethodOutputArgCPP outParameter argsBuilder)
	else
		(argsBuilder "void")
	)

	(#build argsBuilder " " name "(")

	(for (Int32 i = 1)(i < outputIndicator)(i += 1)
		(Sys.Reflection.IExpression parameter = (sMethod i))
			
		(if (parameter.Type == (#Sys.Reflection.ExpressionTypeCompound))
			(if (i > 1)
				(argsBuilder ", ")
			)
			
			(BuildMethodInputArgCPP parameter argsBuilder includeDefaultValues)
		else 
			(parameter.Throw 0 "Unexpected non-compound expression")
		)		
	)
	
	(argsBuilder ")")
)

(function BuildDommeObjectH (DommeContext dc) (Sys.Sexml.ISEXMLDirective domme) -> :
	(IString sxyNamespace = (domme.GetAttributeString "SxyNamespace" true))
	(IString cppNamespace = (NamespaceConvertSxyToCpp sxyNamespace))
	
	(Sys.Sexml.ISEXMLDirectiveList dommeSubdirectives = domme.SubDirectives)
	
	(Sys.Sexml.ISEXMLDirective interfaceDirective = (dommeSubdirectives.GetFirstDirective "Interface" true))
	
	(IString interfaceName = (interfaceDirective.GetAttributeString "Name" true))
	(IString implementationClass = (interfaceDirective.GetAttributeString "Implementation" true))
	
	// TODO Sexysense did not give code completion on cppBuilder, though it works for factoryPrefix
	(Sys.Type.IStringBuilder sb = dc.headerBuilder)
			
	(#build sb "namespace " cppNamespace "&n")
	
	(sb "{&n")
	(#build sb "&tstruct " interfaceName "&n")
	(sb "&t{&n")
	
	(Sys.Sexml.ISEXMLAttribute methods = (interfaceDirective.FindAttribute "Methods"))
	
	// (' Methods ...)
	(Sys.Reflection.IExpression sMethods = methods.S)
	(for (Int32 i = 2)(i < sMethods.ChildCount)(i += 1)
		(Sys.Reflection.IExpression sMethod = (sMethods.Child i))
		(AssertCompound sMethod "Method spec - (Method-Name (input1...)(input2...)->(return-expression)). void methods omit the output indicator '->' and the return-expression")
		
		(IString methodName = (GetAtomicWithAssert sMethod 0 "Expecting method name"))
		(IString methodVariableName = (ToCamelCase methodName))		
		
		(IStringBuilder args = (Sys.Type.NewStringBuilder 256))
		
		(BuildMethodArgsCPP methodName sMethod args true)
		
		(#build sb "&t&tvirtual " args " = 0;&n")
	)
	
	(sb "&t};&n&n")
	
	(#build sb "&tstruct " interfaceName "Supervisor: "  interfaceName "&n")
	(sb "&t{&n")
	(sb "&t&tvirtual void Free() = 0;&n")
	(sb "&t};&n&n")
	
	(#build sb "&t" interfaceName "Supervisor* " dc.factoryPrefix implementationClass "(Rococo::Domme::ScriptingResources& scripting, cstr sourceFile);&n")
	
	(sb "}&n&n")
)

(function Main (Int32 id)->(Int32 exitCode):
	(IString exprPath = (GetCmd "sexml"))
	(if (not (exprPath ?))
		(#printf "Usage: " Sys.IO.ExeName " run=gen_domme_objects.sxy sexml=<domme-sexml-spec-path>")
		(exitCode = -1)
		(return)
	)
	(Sys.Reflection.IExpression expr = (Sys.IO.LoadExpression exprPath))
	(Sys.Sexml.ISEXMLReader reader (Sys.Sexml.ReadSexml expr))
	
	(Sys.Sexml.ISEXMLDirective header = (reader.GetFirstDirective "Header" true))
	
	(IString headerType = (header.GetAttributeString "Type" true))
	(if (not (Sys.Type.Strings.IsExactMatch headerType "Rococo_Domme"))
		(Sys.Reflection.IExpression s = header.S)
		(s.Throw 0 "Cannot find (Type Rococo_Domme) in Header directive")
	)
	
	(IString defaultFactoryPrefix = "New")
	
	(IString headerName = "ICat.h")
	
	(IStringBuilder sb = Sys.Type.NewStringBuilder 4096)
	(IStringBuilder sbHeader = Sys.Type.NewStringBuilder 4096)
		
	(#build sb "#include &"" headerName "&"&n")
	(sb "#include <rococo.domme.h>&n&n")

	(sb "using namespace Rococo;&n")
	(sb "using namespace Rococo::Domme;&n&n")	
		
	(sbHeader "#pragma once&n&n")
	
	(sbHeader "#include <rococo.types.h>&n&n")
	
	(sbHeader "namespace Rococo::Domme&n")
	(sbHeader "{&n")
	(sbHeader "&tstruct ScriptingResources;&n")
	(sbHeader "}&n&n")
	
	(for(Int32 i = 0)(i < reader.DirectiveCount)(i += 1)
		(Sys.Sexml.ISEXMLDirective rootDirective = (reader.Directive i))
		(if (Sys.Type.Strings.IsExactMatch rootDirective.Name "SetDefaults")		
			(defaultFactoryPrefix = (rootDirective.GetAttributeString "CppFactoryPrefix" true))
			(continue)
		)
		
		(DommeContext context = sb sbHeader defaultFactoryPrefix)
		
		(if (Sys.Type.Strings.IsExactMatch rootDirective.Name "Domme")
			(BuildDommeObjectCPP context rootDirective)
			(BuildDommeObjectH context rootDirective)
			(continue)
		)
	)
	
	// define our tab here as four spaces
	(sb.Replace 0 "&t" "    ")
	(#printf sb)
	
	(sbHeader.Replace 0 "&t" "    ")
	(#printf sbHeader)
)