(namespace EntryPoint)
	(alias Main EntryPoint.Main)
	(alias Event EntryPoint.Event)
	(alias Target EntryPoint.Target)
	(alias Arg EntryPoint.Arg)
	(alias ArgWithDefault EntryPoint.ArgWithDefault)

(using Sys.IO)
(using Sys.Type)

(struct EventObjectArg
	(IString typename)
	(IString variableName)
	(IString defaultValue)
)

(struct EventObject
	(IString evNamespace)
	(IString evName)
	(array EventObjectArg args)
)

(struct EventsContext
	(IString rootPath)
	(map IString IStringBuilder cppToBuilder) 
	(map IString IStringBuilder hppToBuilder) 
	(IStringBuilder currentCppBuilder) 
	(IStringBuilder currentHppBuilder) 
	(Bool isEventOpen)
	(array EventObject events)
)

(alias EventsContext EntryPoint.EventsContext)

(function GenerateEvents (IString rootPath)-> :
	(EventsContext ec)
	(ec.rootPath = rootPath)
	(map IString IStringBuilder cppToBuilder) 
	(map IString IStringBuilder hppToBuilder) 
	(ec.cppToBuilder = cppToBuilder)
	(ec.hppToBuilder = hppToBuilder)
	(array EventObject events 1024)
	(ec.events = events)
	(EntryPoint.AddEvents ec) // If this causes a problem, it probably means you had this script executed directly. It should only ever be (' #included) by a script that defines EntryPoint.AddEvents
	
	(SaveFiles ec)
)

(function BuildArgsList (IStringBuilder sb)(EventObject event)-> :
	(sb.Clear)
	(sb "IPublisher&& publisher")
	
	(foreach arg # event.args
		(#build sb ", " arg.typename " " arg.variableName)
	)
)

(function AppendCPPPrelude (EventsContext ec)(Sys.IO.IFileWriter cpp)(IString associatedHeaderFile) -> :
	(IStringBuilder timestamp = NewTokenBuilder)
	(Sys.OS.AppendCTime timestamp)
	(#build cpp "// Generated: " timestamp "&n&n")
	(#build cpp "include &"" associatedHeaderFile "&"&n&n")
	
	(IStringBuilder args = NewParagraphBuilder)
		
	(foreach event # ec.events
		(BuildArgsList args event)
		
		(#build cpp "namespace " event.evNamespace "&n")
		(#build cpp "{&n")
		
		(#build cpp "	void Send" event.evName "(" args ")&n")
		(#build cpp "	{&n")
		
		(#build cpp "	}&n")
		(#build cpp "}&n&n")
	)
)

(function AppendHPPPrelude (Sys.IO.IFileWriter hpp) -> :
	(IStringBuilder timestamp = NewToken)
	(Sys.OS.AppendCTime timestamp)
	(#build hpp "#pragma once&n")
	(#build hpp "// Generated at " timestamp "&n&n")
)

(function SaveFiles (EventsContext ec)-> :
	(foreach cppKeyValue # ec.cppToBuilder
		(
			(IString cppPath = cppKeyValue.Key)
			(IStringBuilder cppData = cppKeyValue.Value)
			(#path fullCppPath ec.rootPath cppPath)
			(Sys.IO.IFileWriter cppWriter = (Sys.IO.WriteToFile fullCppPath))
			(IStringBuilder hppPath = NewPathBuilder)
			(hppPath.AppendIString cppPath)
			(hppPath.Replace 0 ".cpp" ".h")
			(AppendCPPPrelude ec cppWriter hppPath)
			(cppWriter cppData)		
		)
	)
	
	(foreach hppKeyValue # ec.hppToBuilder
		(
			(IString hppPath = hppKeyValue.Key)
			(IStringBuilder hppData = hppKeyValue.Value)
			(#path fullHppPath ec.rootPath hppPath)
			(Sys.IO.IFileWriter hppWriter = (Sys.IO.WriteToFile hppPath))
			(hppWriter hppData)		
		)
	)
)

(function StartsWithSlash (IString path)->(Bool result):
	(result = ((Sys.Type.Strings.StartsWith path "/") or (Sys.Type.Strings.StartsWith path "\")))
)

(function Target (EventsContext ec) (IString cppFilePathRelativeRoot)(IString hppFilePathRelativeRoot)-> :
	(if (StartsWithSlash cppFilePathRelativeRoot)
		(
			(#paragraph message "(Target ec '" cppFilePathRelativeRoot "' ...): cpp Path must not begin with a slash")
			(Sys.Throw 0 message)
		)
	)
	
	(if (StartsWithSlash hppFilePathRelativeRoot)
		(
			(#paragraph message  "(Target ec '" hppFilePathRelativeRoot "' ...): hpp path must not begin with a slash")
			(Sys.Throw 0 message)
		)
	)
	
	(#path cppPath cppFilePathRelativeRoot)
	(#path hppPath hppFilePathRelativeRoot)
	
	(Sys.Type.Strings.MakeSysSlashes cppPath)
	(Sys.Type.Strings.MakeSysSlashes hppPath)
	
	(node cppRef = (ec.cppToBuilder cppPath))
	
	(if (cppRef)
		(ec.currentCppBuilder = cppRef.Value)
	else
		(IStringBuilder sb = (NewStringBuilder 131072))
		(ec.cppToBuilder.Insert cppPath sb)
		(ec.currentCppBuilder = sb)
	)
	
	(node hppRef = (ec.hppToBuilder hppPath))
	
	(if (hppRef)
		(ec.currentHppBuilder = hppRef.Value)
	else
		(IStringBuilder sb = (NewStringBuilder 131072))
		(ec.hppToBuilder.Insert hppPath sb)
		(ec.currentHppBuilder = sb)
	)
)

(function Event (EventsContext ec) (IString evNamespace)(IString evName)-> :
	(EventObject ev)
	(ev.evNamespace = evNamespace)
	(ev.evName = evName)
	(array EventObjectArg args 32)
	(ev.args = args)
	(ec.events.Push ev)
)

(function Arg (EventsContext ec) (IString typeName)(IString variableName)-> :
	(ArgWithDefault ec typeName variableName "")
)

(function ArgWithDefault (EventsContext ec) (IString typeName)(IString variableName)(IString defaultValue)-> :
	(EventObjectArg arg = typeName variableName defaultValue)
	
	(Sys.Throw 0 "Replace this mess with (foreach back # (ec.events.Back) ...")
	
	(Int32 length = (ec.events.Length))
	(Int32 backIndex = (length - 1))

	(foreach back # (ec.events backIndex)
		(back.args.Push arg)
	)
)


// Protocol for Sexy Command Line arguments: '<CMD.EXE> run=<script-name> <key1>=<value1> ... <keyN>=<valueN>'
// Where keyI is not required to be unique. Every KeyI should fit a Sexy #token(<64 chars). Every valueI should fit a #paragraph (<1024 chars).
(function GetNextCmdPathValue (Int32 startIndex)(IString key)->(IString value)(Int32 foundIndex):
	(IStringBuilder sbKey = NewTokenBuilder)
	(IStringBuilder sbValue = NewParagraphBuilder)

	(Int32 argc = Sys.IO.GetCmdArgCount)
	(Int32 i = startIndex)
	(while (i < argc)
		(sbKey.Clear)		
		(sbValue.Clear)
		(Sys.IO.AppendCmdKeyAndValue i sbKey sbValue)
		(if ((Sys.Type.Strings.IsExactMatch key sbKey) and (sbValue.Length > 0))
			(if (sbValue.Length > 259)
				(
					(#paragraph message "The path specified for <" key "> was too long (>= 260 chars)")
					(Sys.Throw 0 message)
				)
			)
			(Sys.Type.Strings.Preserve sbValue -> value)
			(foundIndex = i)
			(return)
		)
		(i += 1)
	)
	
	(foundIndex = argc)
)

(function Main -> (Int32 exitCode):
	(try
		(
			(IString rootPath)
			(Int32 rootIndex)
			(GetNextCmdPathValue 0 "root" -> rootPath rootIndex)

			(if (not (rootPath ?))
				(Sys.Throw 0 "Command line missing 'root=<ROOT-FILEPATH>'")
			)
			
			(Bool isBackSlashed = (Sys.Type.Strings.EndsWith rootPath "\"))
			(Bool isForwardSlashed = (Sys.Type.Strings.EndsWith rootPath "\"))
			
			(if ((not isBackSlashed) and (not isForwardSlashed))
				(Sys.Throw 0 "root did not end with slash: '\' 'root=<ROOT-FILEPATH>'")	
			)

			(GenerateEvents rootPath)
		)
	catch e 
		(
			(#printf e.Message "&n")
			(exitCode = -1)
		)
	)
)