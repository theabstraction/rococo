// Generated by rococo.carpenter. Timestamp: 25/08/2022 21:30:37
// Excel Source: C:\work\rococo\tables\XL\quotes-table.xlsx

#include "tables\quotes-table.h"

#include <rococo.api.h>
#include <rococo.io.h>

#include <vector>

#include <rococo.strings.h>
#include <atomic>
using namespace Rococo;
using namespace Rococo::IO;
using namespace Rococo::Quotes;

namespace Rococo::Quotes
{
    struct QuotesRow: IQuotesRow
    {
        QuoteId id;
        HString text;

        QuoteId GetId() const override { return id; }
        fstring GetText() const override { return text; }
    };
}

static std::vector<QuotesRow> quotesRows;

static void AppendQuotesRows(std::vector<QuotesRow>& rows, const IInstallation& installation, const char* source)
{
    if (!source || !*source) source = "!tables/quotes-table.Quotes_Table.bin";

    struct ANON : ITableRowBuilder
    {
        const char* source = nullptr;
        std::vector<QuotesRow>* rows = nullptr;

        void OnColumns(int numberOfColumns, const ColumnHeader* headers) override
        {
            if (numberOfColumns != 2) Throw(0, "%s: Found %d columns. Expecting 2 columns in %s", __FUNCTION__, numberOfColumns, source);
            ValidateHeader(headers[0], ColumnType::UnderlyingTypeInt32, source);
            ValidateHeader(headers[1], ColumnType::UnderlyingTypeUTF8, source);
        }

        void OnHeaders(const TableRowHeaders& headers) override
        {
            rows->reserve(headers.NumberOfRows);
        }

        void OnRow(ITableRowData& archiveData)
        {
            QuotesRow row;
            row.id = (QuoteId) archiveData.NextInt32();
            row.text = (fstring) archiveData.NextTempString();
            rows->push_back(row);
        }
    } builder;

    builder.source = source;
    builder.rows = &rows;

    ParseTableRows(installation, source, builder);
}

namespace ANON
{
    using namespace Rococo::Quotes;

    struct Quotes_Table_Implementation: IQuotesSupervisor, IQuotes_MetaData, private IQuotes_Sexy
    {
        Rococo::Quotes::IQuotes_Sexy& GetSexyInterface() override
        {
            return *this;
        }

        std::atomic<int32> referenceCount = 0;

        Quotes_Table_Implementation(IInstallation& installation)
        {
            if (referenceCount.fetch_add(1) == 0) AppendQuotesRows(quotesRows, installation, nullptr);
        }

        void Free() override
        {
            if (referenceCount.fetch_sub(1) == 1) { quotesRows.clear(); quotesRows.shrink_to_fit(); }            delete this;
        }

        const IQuotesRow& GetRow(int32 index) const override
        {
            return quotesRows[index];
        }

        // Sexy Interface Method
        void GetRow(int32 index, struct QuotesRowSexy& row) override
        {
            if (index < 0 || index > NumberOfRows()) Throw(0, "%s: [index] out of range.", __FUNCTION__);
            const auto& nativeRow = GetRow(index);
            row.id = nativeRow.GetId();

            Rococo::Script::PopulateStringBuilder(row.text, nativeRow.GetText());
        }

        const int32 NumberOfRows() const override
        {
            return (int32) quotesRows.size();
        }

        // Sexy Interface Method
        int32 NumberOfRows() override
        {
            return (int32) quotesRows.size();
        }

        const IQuotes_MetaData& Meta() const override
        {
            return *this;
        }

        fstring GetTitle() const override
        {
            return "Quote Table"_fstring;
        }

        fstring GetOwner() const override
        {
            return "Mark Anthony Taylor"_fstring;
        }
    };
}

namespace Rococo::Quotes
{
    IQuotesSupervisor* GetQuoteTable(IInstallation& installation)
    {
        return new ANON::Quotes_Table_Implementation(installation);
    }
}

Rococo::Quotes::IQuotes_Sexy* FactoryConstructRococoQuotesGetQuoteTable(Rococo::IInstallation* installation)
{
    auto* instance = new ANON::Quotes_Table_Implementation(*installation);
    return &instance->GetSexyInterface();
}

namespace Rococo::Quotes
{
    fstring ToString(QuoteId value)
    {
        using enum QuoteId;

        switch(value)
        {
        case None: return "None"_fstring;
        case DoctorJohnson1: return "DoctorJohnson1"_fstring;
        case Whistle: return "Whistle"_fstring;
        case Biden: return "Biden"_fstring;
        default: return {nullptr,0};
        }
    }

    bool AppendString(QuoteId value, IStringPopulator& populator)
    {
        fstring s = ToString(value);
        if (s.length == 0) return false;
        populator.Populate(s);
        return true;
    }

    bool TryParse(const fstring& text, QuoteId& result)
    {
        using enum QuoteId;
        struct Binding { cstr key; QuoteId value; }; 
        static Binding bindings[] = {
            {"None", None},{"DoctorJohnson1", DoctorJohnson1},{"Whistle", Whistle},{"Biden", Biden}
        };

        for(auto& b: bindings)
        {
            if (strcmp(b.key, text) == 0)
            {
                result = b.value;
                return true;
            }
        }
        result = QuoteId::None;
        return false;
    }

    tuple<boolean32,QuoteId> TryParseQuoteId(const fstring& text)
    {
        QuoteId value = QuoteId();
        boolean32 wasFound = TryParse(text, value) ? 1 : 0;
        return { wasFound, value };
    }
}

