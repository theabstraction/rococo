// Generated by rococo.carpenter. Timestamp: 12/08/2022 13:38:36
// Excel Source: C:\work\rococo\tables\XL\periodic-table.xlsx

#include "tables\periodic-table.h"

#include <rococo.api.h>
#include <rococo.io.h>

#include <vector>

using namespace Rococo;
using namespace Rococo::IO;
using namespace Rococo::Science::Materials;

static void AppendPeriodicTableRows(std::vector<PeriodicTableRow>& rows, const IInstallation& installation, const char* source)
{
    if (!source || !*source) source = "!tables/periodic-table.Elements_Table.bin";

    struct ANON : ITableRowBuilder
    {
        const char* source = nullptr;
        std::vector<PeriodicTableRow>* rows = nullptr;

        void OnColumns(int numberOfColumns, const ColumnHeader* headers) override
        {
            if (numberOfColumns != 11) Throw(0, "%s: Found %d columns. Expecting 11 columns in %s", __FUNCTION__, numberOfColumns, source);
            ValidateHeader(headers[0], ColumnType::UnderlyingTypeInt32, source);
            ValidateHeader(headers[1], ColumnType::UnderlyingTypeInt32, source);
            ValidateHeader(headers[2], ColumnType::UnderlyingTypeInt32, source);
            ValidateHeader(headers[3], ColumnType::UnderlyingTypeFloat32, source);
            ValidateHeader(headers[4], ColumnType::UnderlyingTypeBool, source);
            ValidateHeader(headers[5], ColumnType::UnderlyingTypeInt32, source);
            ValidateHeader(headers[6], ColumnType::UnderlyingTypeFloat32, source);
            ValidateHeader(headers[7], ColumnType::UnderlyingTypeFloat32, source);
            ValidateHeader(headers[8], ColumnType::UnderlyingTypeFloat32, source);
            ValidateHeader(headers[9], ColumnType::UnderlyingTypeFloat32, source);
            ValidateHeader(headers[10], ColumnType::UnderlyingTypeFloat32, source);
        }

        void OnHeaders(const TableRowHeaders& headers) override
        {
            rows->reserve(headers.NumberOfRows);
        }

        void OnRow(ITableRowData& archiveData)
        {
            PeriodicTableRow row;
            row.atomicNumber = (int32) archiveData.NextInt32();
            row.element = (ElementName) archiveData.NextInt32();
            row.symbol = (ElementSymbol) archiveData.NextInt32();
            row.atomicMass = (float) archiveData.NextFloat32();
            row.metal = (bool) archiveData.NextBool();
            row.elementType = (ElementType) archiveData.NextInt32();
            row.electroNegativity = (float) archiveData.NextFloat32();
            row.firstIonization = (Rococo::SI::ElectronVolts) archiveData.NextFloat32();
            row.density = (float) archiveData.NextFloat32();
            row.meltingPoint = (Rococo::SI::Kelvin) archiveData.NextFloat32();
            row.boilingPoint = (Rococo::SI::Kelvin) archiveData.NextFloat32();
            rows->push_back(row);
        }
    } builder;

    builder.source = source;
    builder.rows = &rows;

    ParseTableRows(installation, source, builder);
}

namespace ANON
{
    using namespace Rococo::Science::Materials;

    struct Elements_Table_Implementation: IPeriodicTableSupervisor, IPeriodicTable_MetaData, private IPeriodicTable_Sexy
    {
        Rococo::Science::Materials::IPeriodicTable_Sexy& GetSexyInterface() override
        {
            return *this;
        }

        std::vector<PeriodicTableRow> periodicTableRows;

        void Free() override
        {
            delete this;
        }

        const PeriodicTableRow& GetRow(int32 index) const override
        {
            return periodicTableRows[index];
        }

        // Sexy Interface Method
        void GetRow(int32 index, struct PeriodicTableRow& row) override
        {
            if (index < 0 || index > NumberOfRows()) Throw(0, "%s: [index] out of range.", __FUNCTION__);
            row = GetRow(index);
        }

        const int32 NumberOfRows() const override
        {
            return (int32) periodicTableRows.size();
        }

        // Sexy Interface Method
        int32 NumberOfRows() override
        {
            return (int32) periodicTableRows.size();
        }

        void Load(const IInstallation& installation, cstr tablePingPath) override
        {
            periodicTableRows.clear();
            AppendPeriodicTableRows(periodicTableRows, installation, tablePingPath);
        }

        const IPeriodicTable_MetaData& Meta() const override
        {
            return *this;
        }

        fstring GetTitle() const override
        {
            return "Periodic Table of the Elements"_fstring;
        }

        fstring GetOwner() const override
        {
            return "Goodman Sciences"_fstring;
        }

        fstring GetURL() const override
        {
            return "https://gist.github.com/GoodmanSciences/"_fstring;
        }
    };
}

namespace Rococo::Science::Materials
{
    IPeriodicTableSupervisor* GetPeriodicTable()
    {
        return new ANON::Elements_Table_Implementation();
    }
}

Rococo::Science::Materials::IPeriodicTable_Sexy* FactoryConstructRococoScienceMaterialsGetPeriodicTable(Rococo::IInstallation* installation)
{
    auto* instance = new ANON::Elements_Table_Implementation();
    instance->Load(*installation, nullptr);
    return &instance->GetSexyInterface();
}

#include <string>
#include <unordered_map>

namespace Rococo::Science::Materials
{
    fstring ToString(ElementName value)
    {
        using enum ElementName;

        switch(value)
        {
        case None: return "None"_fstring;
        case Hydrogen: return "Hydrogen"_fstring;
        case Helium: return "Helium"_fstring;
        case Lithium: return "Lithium"_fstring;
        case Beryllium: return "Beryllium"_fstring;
        case Boron: return "Boron"_fstring;
        case Carbon: return "Carbon"_fstring;
        case Nitrogen: return "Nitrogen"_fstring;
        case Oxygen: return "Oxygen"_fstring;
        case Fluorine: return "Fluorine"_fstring;
        case Neon: return "Neon"_fstring;
        case Sodium: return "Sodium"_fstring;
        case Magnesium: return "Magnesium"_fstring;
        case Aluminum: return "Aluminum"_fstring;
        case Silicon: return "Silicon"_fstring;
        case Phosphorus: return "Phosphorus"_fstring;
        case Sulfur: return "Sulfur"_fstring;
        case Chlorine: return "Chlorine"_fstring;
        case Argon: return "Argon"_fstring;
        case Potassium: return "Potassium"_fstring;
        case Calcium: return "Calcium"_fstring;
        case Scandium: return "Scandium"_fstring;
        case Titanium: return "Titanium"_fstring;
        case Vanadium: return "Vanadium"_fstring;
        case Chromium: return "Chromium"_fstring;
        case Manganese: return "Manganese"_fstring;
        case Iron: return "Iron"_fstring;
        case Cobalt: return "Cobalt"_fstring;
        case Nickel: return "Nickel"_fstring;
        case Copper: return "Copper"_fstring;
        case Zinc: return "Zinc"_fstring;
        case Gallium: return "Gallium"_fstring;
        case Germanium: return "Germanium"_fstring;
        case Arsenic: return "Arsenic"_fstring;
        case Selenium: return "Selenium"_fstring;
        case Bromine: return "Bromine"_fstring;
        case Krypton: return "Krypton"_fstring;
        case Rubidium: return "Rubidium"_fstring;
        case Strontium: return "Strontium"_fstring;
        case Yttrium: return "Yttrium"_fstring;
        case Zirconium: return "Zirconium"_fstring;
        case Niobium: return "Niobium"_fstring;
        case Molybdenum: return "Molybdenum"_fstring;
        case Technetium: return "Technetium"_fstring;
        case Ruthenium: return "Ruthenium"_fstring;
        case Rhodium: return "Rhodium"_fstring;
        case Palladium: return "Palladium"_fstring;
        case Silver: return "Silver"_fstring;
        case Cadmium: return "Cadmium"_fstring;
        case Indium: return "Indium"_fstring;
        case Tin: return "Tin"_fstring;
        case Antimony: return "Antimony"_fstring;
        case Tellurium: return "Tellurium"_fstring;
        case Iodine: return "Iodine"_fstring;
        case Xenon: return "Xenon"_fstring;
        case Cesium: return "Cesium"_fstring;
        case Barium: return "Barium"_fstring;
        case Lanthanum: return "Lanthanum"_fstring;
        case Cerium: return "Cerium"_fstring;
        case Praseodymium: return "Praseodymium"_fstring;
        case Neodymium: return "Neodymium"_fstring;
        case Promethium: return "Promethium"_fstring;
        case Samarium: return "Samarium"_fstring;
        case Europium: return "Europium"_fstring;
        case Gadolinium: return "Gadolinium"_fstring;
        case Terbium: return "Terbium"_fstring;
        case Dysprosium: return "Dysprosium"_fstring;
        case Holmium: return "Holmium"_fstring;
        case Erbium: return "Erbium"_fstring;
        case Thulium: return "Thulium"_fstring;
        case Ytterbium: return "Ytterbium"_fstring;
        case Lutetium: return "Lutetium"_fstring;
        case Hafnium: return "Hafnium"_fstring;
        case Tantalum: return "Tantalum"_fstring;
        case Wolfram: return "Wolfram"_fstring;
        case Rhenium: return "Rhenium"_fstring;
        case Osmium: return "Osmium"_fstring;
        case Iridium: return "Iridium"_fstring;
        case Platinum: return "Platinum"_fstring;
        case Gold: return "Gold"_fstring;
        case Mercury: return "Mercury"_fstring;
        case Thallium: return "Thallium"_fstring;
        case Lead: return "Lead"_fstring;
        case Bismuth: return "Bismuth"_fstring;
        case Polonium: return "Polonium"_fstring;
        case Astatine: return "Astatine"_fstring;
        case Radon: return "Radon"_fstring;
        case Francium: return "Francium"_fstring;
        case Radium: return "Radium"_fstring;
        case Actinium: return "Actinium"_fstring;
        case Thorium: return "Thorium"_fstring;
        case Protactinium: return "Protactinium"_fstring;
        case Uranium: return "Uranium"_fstring;
        case Neptunium: return "Neptunium"_fstring;
        case Plutonium: return "Plutonium"_fstring;
        case Americium: return "Americium"_fstring;
        case Curium: return "Curium"_fstring;
        case Berkelium: return "Berkelium"_fstring;
        case Californium: return "Californium"_fstring;
        case Einsteinium: return "Einsteinium"_fstring;
        case Fermium: return "Fermium"_fstring;
        case Mendelevium: return "Mendelevium"_fstring;
        case Nobelium: return "Nobelium"_fstring;
        case Lawrencium: return "Lawrencium"_fstring;
        case Rutherfordium: return "Rutherfordium"_fstring;
        case Dubnium: return "Dubnium"_fstring;
        case Seaborgium: return "Seaborgium"_fstring;
        case Bohrium: return "Bohrium"_fstring;
        case Hassium: return "Hassium"_fstring;
        case Meitnerium: return "Meitnerium"_fstring;
        case Darmstadtium: return "Darmstadtium"_fstring;
        case Roentgenium: return "Roentgenium"_fstring;
        case Copernicium: return "Copernicium"_fstring;
        case Nihonium: return "Nihonium"_fstring;
        case Flerovium: return "Flerovium"_fstring;
        case Moscovium: return "Moscovium"_fstring;
        case Livermorium: return "Livermorium"_fstring;
        case Tennessine: return "Tennessine"_fstring;
        case Oganesson: return "Oganesson"_fstring;
        default: return {nullptr,0};
        }
    }

    bool AppendString(ElementName value, IStringPopulator& populator)
    {
        fstring s = ToString(value);
        if (s.length == 0) return false;
        populator.Populate(s);
        return true;
    }

    bool TryParse(const fstring& text, ElementName& result)
    {
        using enum ElementName;
        static std::unordered_map<std::string, ElementName> bindings = {
            {"None", None},{"Hydrogen", Hydrogen},{"Helium", Helium},{"Lithium", Lithium},
            {"Beryllium", Beryllium},{"Boron", Boron},{"Carbon", Carbon},{"Nitrogen", Nitrogen},
            {"Oxygen", Oxygen},{"Fluorine", Fluorine},{"Neon", Neon},{"Sodium", Sodium},
            {"Magnesium", Magnesium},{"Aluminum", Aluminum},{"Silicon", Silicon},{"Phosphorus", Phosphorus},
            {"Sulfur", Sulfur},{"Chlorine", Chlorine},{"Argon", Argon},{"Potassium", Potassium},
            {"Calcium", Calcium},{"Scandium", Scandium},{"Titanium", Titanium},{"Vanadium", Vanadium},
            {"Chromium", Chromium},{"Manganese", Manganese},{"Iron", Iron},{"Cobalt", Cobalt},
            {"Nickel", Nickel},{"Copper", Copper},{"Zinc", Zinc},{"Gallium", Gallium},
            {"Germanium", Germanium},{"Arsenic", Arsenic},{"Selenium", Selenium},{"Bromine", Bromine},
            {"Krypton", Krypton},{"Rubidium", Rubidium},{"Strontium", Strontium},{"Yttrium", Yttrium},
            {"Zirconium", Zirconium},{"Niobium", Niobium},{"Molybdenum", Molybdenum},{"Technetium", Technetium},
            {"Ruthenium", Ruthenium},{"Rhodium", Rhodium},{"Palladium", Palladium},{"Silver", Silver},
            {"Cadmium", Cadmium},{"Indium", Indium},{"Tin", Tin},{"Antimony", Antimony},
            {"Tellurium", Tellurium},{"Iodine", Iodine},{"Xenon", Xenon},{"Cesium", Cesium},
            {"Barium", Barium},{"Lanthanum", Lanthanum},{"Cerium", Cerium},{"Praseodymium", Praseodymium},
            {"Neodymium", Neodymium},{"Promethium", Promethium},{"Samarium", Samarium},{"Europium", Europium},
            {"Gadolinium", Gadolinium},{"Terbium", Terbium},{"Dysprosium", Dysprosium},{"Holmium", Holmium},
            {"Erbium", Erbium},{"Thulium", Thulium},{"Ytterbium", Ytterbium},{"Lutetium", Lutetium},
            {"Hafnium", Hafnium},{"Tantalum", Tantalum},{"Wolfram", Wolfram},{"Rhenium", Rhenium},
            {"Osmium", Osmium},{"Iridium", Iridium},{"Platinum", Platinum},{"Gold", Gold},
            {"Mercury", Mercury},{"Thallium", Thallium},{"Lead", Lead},{"Bismuth", Bismuth},
            {"Polonium", Polonium},{"Astatine", Astatine},{"Radon", Radon},{"Francium", Francium},
            {"Radium", Radium},{"Actinium", Actinium},{"Thorium", Thorium},{"Protactinium", Protactinium},
            {"Uranium", Uranium},{"Neptunium", Neptunium},{"Plutonium", Plutonium},{"Americium", Americium},
            {"Curium", Curium},{"Berkelium", Berkelium},{"Californium", Californium},{"Einsteinium", Einsteinium},
            {"Fermium", Fermium},{"Mendelevium", Mendelevium},{"Nobelium", Nobelium},{"Lawrencium", Lawrencium},
            {"Rutherfordium", Rutherfordium},{"Dubnium", Dubnium},{"Seaborgium", Seaborgium},{"Bohrium", Bohrium},
            {"Hassium", Hassium},{"Meitnerium", Meitnerium},{"Darmstadtium", Darmstadtium},{"Roentgenium", Roentgenium},
            {"Copernicium", Copernicium},{"Nihonium", Nihonium},{"Flerovium", Flerovium},{"Moscovium", Moscovium},
            {"Livermorium", Livermorium},{"Tennessine", Tennessine},{"Oganesson", Oganesson}
        };

        auto i = bindings.find(text.buffer);
        if (i != bindings.end())
        {
            result = i->second;
            return true;
        }
        result = ElementName::None;
        return false;
    }

    tuple<boolean32,ElementName> TryParseElementName(const fstring& text)
    {
        ElementName value = ElementName();
        boolean32 wasFound = TryParse(text, value) ? 1 : 0;
        return { wasFound, value };
    }

    fstring ToString(ElementSymbol value)
    {
        using enum ElementSymbol;

        switch(value)
        {
        case None: return "None"_fstring;
        case H: return "H"_fstring;
        case He: return "He"_fstring;
        case Li: return "Li"_fstring;
        case Be: return "Be"_fstring;
        case B: return "B"_fstring;
        case C: return "C"_fstring;
        case N: return "N"_fstring;
        case O: return "O"_fstring;
        case F: return "F"_fstring;
        case Ne: return "Ne"_fstring;
        case Na: return "Na"_fstring;
        case Mg: return "Mg"_fstring;
        case Al: return "Al"_fstring;
        case Si: return "Si"_fstring;
        case P: return "P"_fstring;
        case S: return "S"_fstring;
        case Cl: return "Cl"_fstring;
        case Ar: return "Ar"_fstring;
        case K: return "K"_fstring;
        case Ca: return "Ca"_fstring;
        case Sc: return "Sc"_fstring;
        case Ti: return "Ti"_fstring;
        case V: return "V"_fstring;
        case Cr: return "Cr"_fstring;
        case Mn: return "Mn"_fstring;
        case Fe: return "Fe"_fstring;
        case Co: return "Co"_fstring;
        case Ni: return "Ni"_fstring;
        case Cu: return "Cu"_fstring;
        case Zn: return "Zn"_fstring;
        case Ga: return "Ga"_fstring;
        case Ge: return "Ge"_fstring;
        case As: return "As"_fstring;
        case Se: return "Se"_fstring;
        case Br: return "Br"_fstring;
        case Kr: return "Kr"_fstring;
        case Rb: return "Rb"_fstring;
        case Sr: return "Sr"_fstring;
        case Y: return "Y"_fstring;
        case Zr: return "Zr"_fstring;
        case Nb: return "Nb"_fstring;
        case Mo: return "Mo"_fstring;
        case Tc: return "Tc"_fstring;
        case Ru: return "Ru"_fstring;
        case Rh: return "Rh"_fstring;
        case Pd: return "Pd"_fstring;
        case Ag: return "Ag"_fstring;
        case Cd: return "Cd"_fstring;
        case In: return "In"_fstring;
        case Sn: return "Sn"_fstring;
        case Sb: return "Sb"_fstring;
        case Te: return "Te"_fstring;
        case I: return "I"_fstring;
        case Xe: return "Xe"_fstring;
        case Cs: return "Cs"_fstring;
        case Ba: return "Ba"_fstring;
        case La: return "La"_fstring;
        case Ce: return "Ce"_fstring;
        case Pr: return "Pr"_fstring;
        case Nd: return "Nd"_fstring;
        case Pm: return "Pm"_fstring;
        case Sm: return "Sm"_fstring;
        case Eu: return "Eu"_fstring;
        case Gd: return "Gd"_fstring;
        case Tb: return "Tb"_fstring;
        case Dy: return "Dy"_fstring;
        case Ho: return "Ho"_fstring;
        case Er: return "Er"_fstring;
        case Tm: return "Tm"_fstring;
        case Yb: return "Yb"_fstring;
        case Lu: return "Lu"_fstring;
        case Hf: return "Hf"_fstring;
        case Ta: return "Ta"_fstring;
        case W: return "W"_fstring;
        case Re: return "Re"_fstring;
        case Os: return "Os"_fstring;
        case Ir: return "Ir"_fstring;
        case Pt: return "Pt"_fstring;
        case Au: return "Au"_fstring;
        case Hg: return "Hg"_fstring;
        case Tl: return "Tl"_fstring;
        case Pb: return "Pb"_fstring;
        case Bi: return "Bi"_fstring;
        case Po: return "Po"_fstring;
        case At: return "At"_fstring;
        case Rn: return "Rn"_fstring;
        case Fr: return "Fr"_fstring;
        case Ra: return "Ra"_fstring;
        case Ac: return "Ac"_fstring;
        case Th: return "Th"_fstring;
        case Pa: return "Pa"_fstring;
        case U: return "U"_fstring;
        case Np: return "Np"_fstring;
        case Pu: return "Pu"_fstring;
        case Am: return "Am"_fstring;
        case Cm: return "Cm"_fstring;
        case Bk: return "Bk"_fstring;
        case Cf: return "Cf"_fstring;
        case Es: return "Es"_fstring;
        case Fm: return "Fm"_fstring;
        case Md: return "Md"_fstring;
        case No: return "No"_fstring;
        case Lr: return "Lr"_fstring;
        case Rf: return "Rf"_fstring;
        case Db: return "Db"_fstring;
        case Sg: return "Sg"_fstring;
        case Bh: return "Bh"_fstring;
        case Hs: return "Hs"_fstring;
        case Mt: return "Mt"_fstring;
        case Ds: return "Ds"_fstring;
        case Rg: return "Rg"_fstring;
        case Cn: return "Cn"_fstring;
        case Nh: return "Nh"_fstring;
        case Fl: return "Fl"_fstring;
        case Mc: return "Mc"_fstring;
        case Lv: return "Lv"_fstring;
        case Ts: return "Ts"_fstring;
        case Og: return "Og"_fstring;
        default: return {nullptr,0};
        }
    }

    bool AppendString(ElementSymbol value, IStringPopulator& populator)
    {
        fstring s = ToString(value);
        if (s.length == 0) return false;
        populator.Populate(s);
        return true;
    }

    bool TryParse(const fstring& text, ElementSymbol& result)
    {
        using enum ElementSymbol;
        static std::unordered_map<std::string, ElementSymbol> bindings = {
            {"None", None},{"H", H},{"He", He},{"Li", Li},
            {"Be", Be},{"B", B},{"C", C},{"N", N},
            {"O", O},{"F", F},{"Ne", Ne},{"Na", Na},
            {"Mg", Mg},{"Al", Al},{"Si", Si},{"P", P},
            {"S", S},{"Cl", Cl},{"Ar", Ar},{"K", K},
            {"Ca", Ca},{"Sc", Sc},{"Ti", Ti},{"V", V},
            {"Cr", Cr},{"Mn", Mn},{"Fe", Fe},{"Co", Co},
            {"Ni", Ni},{"Cu", Cu},{"Zn", Zn},{"Ga", Ga},
            {"Ge", Ge},{"As", As},{"Se", Se},{"Br", Br},
            {"Kr", Kr},{"Rb", Rb},{"Sr", Sr},{"Y", Y},
            {"Zr", Zr},{"Nb", Nb},{"Mo", Mo},{"Tc", Tc},
            {"Ru", Ru},{"Rh", Rh},{"Pd", Pd},{"Ag", Ag},
            {"Cd", Cd},{"In", In},{"Sn", Sn},{"Sb", Sb},
            {"Te", Te},{"I", I},{"Xe", Xe},{"Cs", Cs},
            {"Ba", Ba},{"La", La},{"Ce", Ce},{"Pr", Pr},
            {"Nd", Nd},{"Pm", Pm},{"Sm", Sm},{"Eu", Eu},
            {"Gd", Gd},{"Tb", Tb},{"Dy", Dy},{"Ho", Ho},
            {"Er", Er},{"Tm", Tm},{"Yb", Yb},{"Lu", Lu},
            {"Hf", Hf},{"Ta", Ta},{"W", W},{"Re", Re},
            {"Os", Os},{"Ir", Ir},{"Pt", Pt},{"Au", Au},
            {"Hg", Hg},{"Tl", Tl},{"Pb", Pb},{"Bi", Bi},
            {"Po", Po},{"At", At},{"Rn", Rn},{"Fr", Fr},
            {"Ra", Ra},{"Ac", Ac},{"Th", Th},{"Pa", Pa},
            {"U", U},{"Np", Np},{"Pu", Pu},{"Am", Am},
            {"Cm", Cm},{"Bk", Bk},{"Cf", Cf},{"Es", Es},
            {"Fm", Fm},{"Md", Md},{"No", No},{"Lr", Lr},
            {"Rf", Rf},{"Db", Db},{"Sg", Sg},{"Bh", Bh},
            {"Hs", Hs},{"Mt", Mt},{"Ds", Ds},{"Rg", Rg},
            {"Cn", Cn},{"Nh", Nh},{"Fl", Fl},{"Mc", Mc},
            {"Lv", Lv},{"Ts", Ts},{"Og", Og}
        };

        auto i = bindings.find(text.buffer);
        if (i != bindings.end())
        {
            result = i->second;
            return true;
        }
        result = ElementSymbol::None;
        return false;
    }

    tuple<boolean32,ElementSymbol> TryParseElementSymbol(const fstring& text)
    {
        ElementSymbol value = ElementSymbol();
        boolean32 wasFound = TryParse(text, value) ? 1 : 0;
        return { wasFound, value };
    }

    fstring ToString(ElementType value)
    {
        using enum ElementType;

        switch(value)
        {
        case None: return "None"_fstring;
        case Nonmetal: return "Nonmetal"_fstring;
        case NobleGas: return "NobleGas"_fstring;
        case AlkaliMetal: return "AlkaliMetal"_fstring;
        case AlkalineEarthMetal: return "AlkalineEarthMetal"_fstring;
        case Metalloid: return "Metalloid"_fstring;
        case Halogen: return "Halogen"_fstring;
        case Metal: return "Metal"_fstring;
        case TransitionMetal: return "TransitionMetal"_fstring;
        case Lanthanide: return "Lanthanide"_fstring;
        case Actinide: return "Actinide"_fstring;
        case Transactinide: return "Transactinide"_fstring;
        default: return {nullptr,0};
        }
    }

    bool AppendString(ElementType value, IStringPopulator& populator)
    {
        fstring s = ToString(value);
        if (s.length == 0) return false;
        populator.Populate(s);
        return true;
    }

    bool TryParse(const fstring& text, ElementType& result)
    {
        using enum ElementType;
        static std::unordered_map<std::string, ElementType> bindings = {
            {"None", None},{"Nonmetal", Nonmetal},{"NobleGas", NobleGas},{"AlkaliMetal", AlkaliMetal},
            {"AlkalineEarthMetal", AlkalineEarthMetal},{"Metalloid", Metalloid},{"Halogen", Halogen},{"Metal", Metal},
            {"TransitionMetal", TransitionMetal},{"Lanthanide", Lanthanide},{"Actinide", Actinide},{"Transactinide", Transactinide}
        };

        auto i = bindings.find(text.buffer);
        if (i != bindings.end())
        {
            result = i->second;
            return true;
        }
        result = ElementType::None;
        return false;
    }

    tuple<boolean32,ElementType> TryParseElementType(const fstring& text)
    {
        ElementType value = ElementType();
        boolean32 wasFound = TryParse(text, value) ? 1 : 0;
        return { wasFound, value };
    }
}

