// Generated by rococo.carpenter. Timestamp: 03/04/2022 13:55:00
// Excel Source: C:\work\rococo\tables\quotes-table.xlsx

#include "tables\rococo.quotes.h"

#include <rococo.api.h>
#include <rococo.io.h>

#include <vector>

using namespace Rococo;
using namespace Rococo::IO;
using namespace Rococo::Quotes;

static std::vector<Quotes_Row> rows;

static void AppendQuotes_Rows(std::vector<Quotes_Row>& rows, const IInstallation& installation, const char* source)
{
    if (!source || !*source) source = "!tables/rococo.quotes.Quotes_Table.bin";

    struct ANON : ITableRowBuilder
    {
        const char* source = nullptr;
        std::vector<Quotes_Row>* rows = nullptr;

        void OnColumns(int numberOfColumns, const ColumnHeader* headers) override
        {
            if (numberOfColumns != 2) Throw(0, "%s: Found %d columns. Expecting 2 columns in %s", __FUNCTION__, numberOfColumns, source);
            ValidateHeader(headers[0], ColumnType::UnderlyingTypeInt32, source);
            ValidateHeader(headers[1], ColumnType::UnderlyingTypeUTF8, source);
        }

        void OnHeaders(const TableRowHeaders& headers) override
        {
            rows->reserve(headers.NumberOfRows);
        }

        void OnRow(ITableRowData& archiveData)
        {
            Quotes_Row row;
            row.id = (QuoteId) archiveData.NextInt32();
            row.text = (fstring) archiveData.NextTempString();
            rows->push_back(row);
        }
    } builder;

    builder.source = source;
    builder.rows = &rows;

    ParseTableRows(installation, source, builder);
}

namespace ANON
{
    using namespace Rococo::Quotes;

    struct Quotes_Table_Implementation: IQuotesSupervisor, IQuotes_MetaData
    {
        void Free() override
        {
            delete this;
        }

        const Quotes_Row& GetRow(int32 index) const override
        {
            return rows[index];
        }

        const int32 NumberOfRows() const override
        {
            return (int32) rows.size();
        }

        const IQuotes_MetaData& Meta() const override
        {
            return *this;
        }

        fstring GetTitle() const override
        {
            return "Quote Table"_fstring;
        }

        fstring GetOwner() const override
        {
            return "Mark Anthony Taylor"_fstring;
        }
    };
}

namespace Rococo::Quotes
{
    IQuotesSupervisor* GetQuoteTable()
    {
        return new ANON::Quotes_Table_Implementation();
    }
}

#include <string.h>
namespace Rococo::Quotes
{
    fstring ToString(QuoteId value)
    {
        using enum QuoteId;

        switch(value)
        {
        case None: return "None"_fstring;
        case DoctorJohnson1: return "DoctorJohnson1"_fstring;
        case Whistle: return "Whistle"_fstring;
        case Biden: return "Biden"_fstring;
        default: return {nullptr,0};
        }
    }

    bool TryParse(const fstring& text, QuoteId& result)
    {
        using enum QuoteId;
        struct Binding { cstr key; QuoteId value; }; 
        static Binding bindings[] = {
            {"None", None},{"DoctorJohnson1", DoctorJohnson1},{"Whistle", Whistle},{"Biden", Biden}
        };

        for(auto& b: bindings)
        {
            if (strcmp(b.key, text) == 0)
            {
                result = b.value;
                return true;
            }
        }
        result = QuoteId::None;
        return false;
    }
}
