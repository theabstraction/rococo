// Generated by rococo.carpenter. Timestamp: 07/04/2022 16:13:27
// Excel Source: C:\work\rococo\tables\quotes-table.xlsx

#include "tables\rococo.quotes.h"

#include <rococo.api.h>
#include <rococo.io.h>

#include <vector>

#include <rococo.strings.h>
#include <atomic>
using namespace Rococo;
using namespace Rococo::IO;
using namespace Rococo::Quotes;

namespace Rococo::Quotes
{
    struct Quotes_Row: IQuotes_Row
    {
        QuoteId id;
        HString text;

        QuoteId GetId() const override { return id; }
        fstring GetText() const override { return fstring { text.c_str(), (int32) text.length() }; }
    };
}

static std::vector<Quotes_Row> rows;

static void AppendQuotes_Rows(std::vector<Quotes_Row>& rows, const IInstallation& installation, const char* source)
{
    if (!source || !*source) source = "!tables/rococo.quotes.Quotes_Table.bin";

    struct ANON : ITableRowBuilder
    {
        const char* source = nullptr;
        std::vector<Quotes_Row>* rows = nullptr;

        void OnColumns(int numberOfColumns, const ColumnHeader* headers) override
        {
            if (numberOfColumns != 2) Throw(0, "%s: Found %d columns. Expecting 2 columns in %s", __FUNCTION__, numberOfColumns, source);
            ValidateHeader(headers[0], ColumnType::UnderlyingTypeInt32, source);
            ValidateHeader(headers[1], ColumnType::UnderlyingTypeUTF8, source);
        }

        void OnHeaders(const TableRowHeaders& headers) override
        {
            rows->reserve(headers.NumberOfRows);
        }

        void OnRow(ITableRowData& archiveData)
        {
            Quotes_Row row;
            row.id = (QuoteId) archiveData.NextInt32();
            row.text = (fstring) archiveData.NextTempString();
            rows->push_back(row);
        }
    } builder;

    builder.source = source;
    builder.rows = &rows;

    ParseTableRows(installation, source, builder);
}

namespace ANON
{
    using namespace Rococo::Quotes;

    struct Quotes_Table_Implementation: IQuotesSupervisor, IQuotes_MetaData
    {
        std::atomic<int32> referenceCount = 0;

        Quotes_Table_Implementation(IInstallation& installation)
        {
            if (referenceCount.fetch_add(1) == 0) AppendQuotes_Rows(rows, installation, nullptr);
        }

        void Free() override
        {
            if (referenceCount.fetch_sub(1) == 1) { rows.clear(); rows.shrink_to_fit(); }
            delete this;
        }

        const IQuotes_Row& GetRow(int32 index) const override
        {
            return rows[index];
        }

        const int32 NumberOfRows() const override
        {
            return (int32) rows.size();
        }

        const IQuotes_MetaData& Meta() const override
        {
            return *this;
        }

        fstring GetTitle() const override
        {
            return "Quote Table"_fstring;
        }

        fstring GetOwner() const override
        {
            return "Mark Anthony Taylor"_fstring;
        }
    };
}

namespace Rococo::Quotes
{
    IQuotesSupervisor* GetQuoteTable(IInstallation& installation)
    {
        return new ANON::Quotes_Table_Implementation(installation);
    }
}

namespace Rococo::Quotes
{
    fstring ToString(QuoteId value)
    {
        using enum QuoteId;

        switch(value)
        {
        case None: return "None"_fstring;
        case DoctorJohnson1: return "DoctorJohnson1"_fstring;
        case Whistle: return "Whistle"_fstring;
        case Biden: return "Biden"_fstring;
        default: return {nullptr,0};
        }
    }

    bool TryParse(const fstring& text, QuoteId& result)
    {
        using enum QuoteId;
        struct Binding { cstr key; QuoteId value; }; 
        static Binding bindings[] = {
            {"None", None},{"DoctorJohnson1", DoctorJohnson1},{"Whistle", Whistle},{"Biden", Biden}
        };

        for(auto& b: bindings)
        {
            if (strcmp(b.key, text) == 0)
            {
                result = b.value;
                return true;
            }
        }
        result = QuoteId::None;
        return false;
    }
}
