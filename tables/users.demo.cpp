// Generated by rococo.carpenter. Timestamp: 10/04/2022 22:34:39
// Excel Source: C:\work\rococo\tables\users.demo.xlsx

#include "tables\users.demo.h"
#include <rococo.hashtable.h>

#include <rococo.api.h>
#include <rococo.io.h>

#include <vector>

#include <rococo.strings.h>
#include <atomic>
using namespace Rococo;
using namespace Rococo::IO;
using namespace Rococo::Test::UserDemo;

namespace Rococo::Test::UserDemo
{
    struct Users_Row: IUsers_Row
    {
        HString ownerId;
        int64 purchaseId;

        fstring GetOwnerId() const override { return ownerId; }
        int64 GetPurchaseId() const override { return purchaseId; }
    };
}

static std::vector<Users_Row> rows;

static stringmap<size_t> ownerId_to_index;
static std::unordered_map<int64, size_t> purchaseId_to_index;

static void AppendUsers_Rows(stringmap<size_t>& ownerId_to_index, std::unordered_map<int64, size_t>& purchaseId_to_index, std::vector<Users_Row>& rows, const IInstallation& installation, const char* source)
{
    if (!source || !*source) source = "!tables/users.demo.Users_Table.bin";

    struct ANON : ITableRowBuilder
    {
        const char* source = nullptr;
        std::vector<Users_Row>* rows = nullptr;

        void OnColumns(int numberOfColumns, const ColumnHeader* headers) override
        {
            if (numberOfColumns != 2) Throw(0, "%s: Found %d columns. Expecting 2 columns in %s", __FUNCTION__, numberOfColumns, source);
            ValidateHeader(headers[0], ColumnType::UnderlyingTypeUTF8, source);
            ValidateHeader(headers[1], ColumnType::UnderlyingTypeInt64, source);
        }

        void OnHeaders(const TableRowHeaders& headers) override
        {
            rows->reserve(headers.NumberOfRows);
        }

        void OnRow(ITableRowData& archiveData)
        {
            Users_Row row;
            row.ownerId = (fstring) archiveData.NextTempString();
            row.purchaseId = (int64) archiveData.NextInt64();
            rows->push_back(row);
        }
    } builder;

    builder.source = source;
    builder.rows = &rows;

    ParseTableRows(installation, source, builder);

    for (size_t i = 0; i < rows.size(); ++i)
    {
        auto & r = rows[i];
        auto j = ownerId_to_index.insert(r.ownerId, i);
        if (!j.second)
        {
            Throw(0, " %s: Duplicate 'OwnerId' at row %llu. First seen at row %llu", source, i, j.first->second);
        }
    }

    for (size_t i = 0; i < rows.size(); ++i)
    {
        auto & r = rows[i];
        auto j = purchaseId_to_index.insert(std::make_pair(r.purchaseId, i));
        if (!j.second)
        {
            Throw(0, " %s: Duplicate 'PurchaseId' at row %llu. First seen at row %llu", source, i, j.first->second);
        }
    }
}

namespace ANON
{
    using namespace Rococo::Test::UserDemo;

    struct Users_Table_Implementation: IUsersSupervisor, IUsers_MetaData
    {
        std::atomic<int32> referenceCount = 0;

        Users_Table_Implementation(IInstallation& installation)
        {
            if (referenceCount.fetch_add(1) == 0) AppendUsers_Rows(ownerId_to_index, purchaseId_to_index, rows, installation, nullptr);
        }

        void Free() override
        {
            if (referenceCount.fetch_sub(1) == 1) { rows.clear(); rows.shrink_to_fit(); }
            delete this;
        }

        const IUsers_Row& GetRow(int32 index) const override
        {
            return rows[index];
        }

        const int32 NumberOfRows() const override
        {
            return (int32) rows.size();
        }

        const IUsers_MetaData& Meta() const override
        {
            return *this;
        }

        const IUsers_Row* FindRowByOwnerId(fstring ownerId, int32& index) const override
        {
            auto i = ownerId_to_index.find(ownerId);
            if (i != ownerId_to_index.end()) { index = (int32) i->second; return &rows[index]; }
            else { index = -1; return nullptr; }
        }

        const IUsers_Row* FindRowByPurchaseId(int64 purchaseId, int32& index) const override
        {
            auto i = purchaseId_to_index.find(purchaseId);
            if (i != purchaseId_to_index.end()) { index = (int32) i->second; return &rows[index]; }
            else { index = -1; return nullptr; }
        }

        fstring GetTitle() const override
        {
            return "User Table"_fstring;
        }

        fstring GetOwner() const override
        {
            return "Mark Anthony Taylor"_fstring;
        }
    };
}

namespace Rococo::Test::UserDemo
{
    IUsersSupervisor* GetUserTable(IInstallation& installation)
    {
        return new ANON::Users_Table_Implementation(installation);
    }
}
