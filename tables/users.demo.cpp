// Generated by rococo.carpenter. Timestamp: 26/08/2022 21:26:50
// Excel Source: C:\work\rococo\tables\XL\users.demo.xlsx

#include "tables\users.demo.h"
#include <rococo.hashtable.h>

#include <rococo.api.h>
#include <rococo.io.h>

#include <vector>

#include <rococo.strings.h>
#include <atomic>
using namespace Rococo;
using namespace Rococo::IO;
using namespace Rococo::Test::UserDemo;

namespace Rococo::Test::UserDemo
{
    struct UsersRow: IUsersRow
    {
        HString ownerId;
        int64 purchaseId;

        fstring GetOwnerId() const override { return ownerId; }
        int64 GetPurchaseId() const override { return purchaseId; }
    };
}

static std::vector<UsersRow> usersRows;

static stringmap<size_t> ownerId_to_index;
static std::unordered_map<int64, size_t> purchaseId_to_index;

static void AppendUsersRows(stringmap<size_t>& ownerId_to_index, std::unordered_map<int64, size_t>& purchaseId_to_index, std::vector<UsersRow>& rows, const IInstallation& installation, const char* source)
{
    if (!source || !*source) source = "!tables/users.demo.Users_Table.bin";

    struct ANON : ITableRowBuilder
    {
        const char* source = nullptr;
        std::vector<UsersRow>* rows = nullptr;

        void OnColumns(int numberOfColumns, const ColumnHeader* headers) override
        {
            if (numberOfColumns != 2) Throw(0, "%s: Found %d columns. Expecting 2 columns in %s", __FUNCTION__, numberOfColumns, source);
            ValidateHeader(headers[0], ColumnType::UnderlyingTypeUTF8, source);
            ValidateHeader(headers[1], ColumnType::UnderlyingTypeInt64, source);
        }

        void OnHeaders(const TableRowHeaders& headers) override
        {
            rows->reserve(headers.NumberOfRows);
        }

        void OnRow(ITableRowData& archiveData)
        {
            UsersRow row;
            row.ownerId = (fstring) archiveData.NextTempString();
            row.purchaseId = (int64) archiveData.NextInt64();
            rows->push_back(row);
        }
    } builder;

    builder.source = source;
    builder.rows = &rows;

    ParseTableRows(installation, source, builder);

    for (size_t i = 0; i < usersRows.size(); ++i)
    {
        auto & r = usersRows[i];
        auto j = ownerId_to_index.insert(r.ownerId, i);
        if (!j.second)
        {
            Throw(0, " %s: Duplicate 'OwnerId' at row %llu. First seen at row %llu", source, i, j.first->second);
        }
    }

    for (size_t i = 0; i < usersRows.size(); ++i)
    {
        auto & r = usersRows[i];
        auto j = purchaseId_to_index.insert(std::make_pair(r.purchaseId, i));
        if (!j.second)
        {
            Throw(0, " %s: Duplicate 'PurchaseId' at row %llu. First seen at row %llu", source, i, j.first->second);
        }
    }
}

namespace ANON
{
    using namespace Rococo::Test::UserDemo;

    struct Users_Table_Implementation: IUsersSupervisor, IUsers_MetaData, private IUsers_Sexy
    {
        Rococo::Test::UserDemo::IUsers_Sexy& GetSexyInterface() override
        {
            return *this;
        }

        std::atomic<int32> referenceCount = 0;

        Users_Table_Implementation(IInstallation& installation)
        {
            if (referenceCount.fetch_add(1) == 0) AppendUsersRows(ownerId_to_index, purchaseId_to_index, usersRows, installation, nullptr);
        }

        void Free() override
        {
            if (referenceCount.fetch_sub(1) == 1) { usersRows.clear(); usersRows.shrink_to_fit(); }            delete this;
        }

        const IUsersRow& GetRow(int32 index) const override
        {
            return usersRows[index];
        }

        // Sexy Interface Method
        void GetRow(int32 index, struct UsersRowSexy& row) override
        {
            if (index < 0 || index > NumberOfRows()) Throw(0, "%s: [index] out of range.", __FUNCTION__);
            const auto& nativeRow = GetRow(index);
            Rococo::Script::PopulateStringBuilder(row.ownerId, nativeRow.GetOwnerId());
            row.purchaseId = nativeRow.GetPurchaseId();

        }

        const int32 NumberOfRows() const override
        {
            return (int32) usersRows.size();
        }

        // Sexy Interface Method
        int32 NumberOfRows() override
        {
            return (int32) usersRows.size();
        }

        const IUsers_MetaData& Meta() const override
        {
            return *this;
        }

        const IUsersRow* FindRowByOwnerId(fstring ownerId, int32& index) const override
        {
            auto i = ownerId_to_index.find(ownerId);
            if (i != ownerId_to_index.end()) { index = (int32) i->second; return &usersRows[index]; }
            else { index = -1; return nullptr; }
        }

        const IUsersRow* FindRowByPurchaseId(int64 purchaseId, int32& index) const override
        {
            auto i = purchaseId_to_index.find(purchaseId);
            if (i != purchaseId_to_index.end()) { index = (int32) i->second; return &usersRows[index]; }
            else { index = -1; return nullptr; }
        }

        fstring GetTitle() const override
        {
            return "User Table"_fstring;
        }

        fstring GetOwner() const override
        {
            return "Mark Anthony Taylor"_fstring;
        }
    };
}

namespace Rococo::Test::UserDemo
{
    IUsersSupervisor* GetUserTable(IInstallation& installation)
    {
        return new ANON::Users_Table_Implementation(installation);
    }
}

Rococo::Test::UserDemo::IUsers_Sexy* FactoryConstructRococoTestUserDemoGetUserTable(Rococo::IInstallation* installation)
{
    auto* instance = new ANON::Users_Table_Implementation(*installation);
    return &instance->GetSexyInterface();
}
